<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>使用Hexo搭建个人博客（VPS+Git+Apache2）</title>
    <url>/2020/05/19/%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>长期以来购买的国外VPS只是在进行代理转发的服务，然而现在DigitalOcean的最低价格的服务器配置也相当可以了。因此最近想来再多利用一下花钱买到的资源，就有了搭建个人博客的想法。希望能通过这种方式，同时勉励一下自己养成学习记录的好习惯吧。（CS知识真的是博大精深，有时候看一遍过段时间就忘了）</p>
<p>我使用的是Hexo框架搭建的博客。它的好处是可以直接<strong>在服务端部署静态的网站</strong>，本地打包上传，相比于WordPress这种主流框架来说，更加轻量级一些。</p>
<p>整个的框架流程是这样的：本地的Hexo分为源代码和<code>generate</code>后的静态文件两部分；Hexo源代码放在GitHub上进行托管（<code>.git</code>与远端连接）；本地的静态文件（<code>.deploy_git</code>）与VPS上的Git仓库连接（<code>/home/git</code>），最后再通过Git Hooks更新到Apache2的服务目录下（<code>/var/www</code>）</p>
<figure>
<img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gexv2xfxowj30uf0cwwfg.jpg" alt="" /><figcaption>博客流程图</figcaption>
</figure>
<p>整个搭建过程最主要参考了<a href="http://paranoth.com/2017/10/29/Hexo%E5%BB%BA%E7%AB%99%E8%AE%B0%E5%BD%95/" target="_blank" rel="noopener">Hexo建站记录(VPS+git+apache2)</a>这篇文章，在一些细节上稍有不同。</p>
<p>个人的服务器是Ubuntu 18.04的版本，本地电脑是Mac OS。</p>
<h2 id="本地端搭建hexo">本地端搭建Hexo</h2>
<p>这里的搭建过程按照<a href="https://mupceet.com/2019/08/build-blog-based-on-hexo/" target="_blank" rel="noopener">Hexo 博客搭建与主题配置（零基础版）</a>来就可以了，只用看文章的前半部分。以上操作全部在PC端本地完成。需要注意的是，这里的Node.js版本不要使用最新的v14（我使用的是<code>v13.1.0</code>），否则在使用<code>npm</code>安装<code>hexo-cli</code>时会有莫名其妙的错误。</p>
<p>对于Hexo的配置（主要是<code>_config.yml</code>）和基础命令，可以查看<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">Hexo的官方文档</a>来进行了解。这里吐槽一下，文档写的不怎么样，但是了解一下基础还是可以的。</p>
<p>我不是很喜欢Hexo自带的Landscape主题。这里我搭建的Hexo使用Next.Pisces主题，当时第一次看到这个主题的博客网页就非常喜欢，就用它了！</p>
<p>主要参考了这篇文章：<a href="https://sjq597.github.io/2018/05/15/Hexo%E4%BD%BF%E7%94%A8next-Pisces%E4%B8%BB%E9%A2%98/" target="_blank" rel="noopener">Hexo使用next.Pisces主题</a></p>
<p>以及Next主题的<a href="https://github.com/theme-next/hexo-theme-next" target="_blank" rel="noopener">Github源码</a></p>
<h2 id="配置vps的git仓库">配置VPS的Git仓库</h2>
<p>这里我在Ubuntu上新创建了一个名为<code>git</code>的用户，远程代码仓库放在了<code>/home/git/BlogGit</code>下。在笔记本本地项目HexoBlog中的<code>_config.yml</code>配置文件里，可以查看deploy的配置。</p>
<p>与远程服务器的连接通信，需要生成SSH的密钥，这里<a href="https://www.ssh.com/ssh/keygen/" target="_blank" rel="noopener">SSH官网</a>上说的很清楚。我使用的是ECDSA的521位的密钥算法，相比于RSA 2048位，4096位的算法更为安全一些，也是目前推荐使用的新密钥算法。在使用<code>ssh-copy-id</code>命令向服务器上的<code>/home/git/authorized_keys</code>文件中传递公钥时，需要注意设置<code>sshd_config</code>的<strong>PasswordAuthentication</strong>为<strong>yes</strong>，之后再改回来。这里参考了<a href="https://www.digitalocean.com/community/questions/ssh-copy-id-not-working-permission-denied-publickey" target="_blank" rel="noopener">ssh-copy-id not working Permission denied (publickey)</a>问题下面的回答。</p>
<p>对于使用SSH进行<code>命令行选项</code>或<code>用户配置文件</code>的方式进行连接，<a href="https://daemon369.github.io/ssh/2015/03/21/using-ssh-config-file" target="_blank" rel="noopener">使用 SSH config 文件</a>这篇文章说的比较清楚。简而言之，使用命令行和使用用户配置文件的方式是可以等价互换的。我使用的是<code>用户配置文件的</code>方式，这样在之后的命令中更为方便一些。配置文件config在本地Mac OS上的<code>/Users/zsh/.ssh</code>目录下，上面有详细的注释。</p>
<h2 id="配置vps的apache2相关">配置VPS的Apache2相关</h2>
<p>由于最初自己在搭建服务器的时候使用的是LAMP+WordPress的模式，所以基本上所有和Apache2服务器有关的坑几乎都踩过一遍了。一般来说，按照教程来是没有问题的。这里我想特别推荐一下DigitalOcean Community中的有关教程，是在是太友好了，让我这个什么都不懂的人也能比较规范的来进行服务器的搭建操作。为此每个月使用DigitalOcean花5刀维持服务器我也愿意！下面就简单说一下当时的一些操作，以及事后需要注意维护的地方。</p>
<p>使用namecheap申请注册免费域名，和DigitalOcean建立联系，主要参考了：</p>
<p><a href="https://www.jianshu.com/p/b0fa42218ae6" target="_blank" rel="noopener">在namecheap申请域名并在digitalocean中对该域名进行绑定</a></p>
<p>对DigitalOcean服务器droplet的操作，这里主要参考了以下几篇文章：</p>
<ol type="1">
<li><p><a href="https://www.digitalocean.com/community/tutorials/how-to-install-mysql-on-ubuntu-18-04" target="_blank" rel="noopener">How To Install MySQL on Ubuntu 18.04</a></p></li>
<li><p><a href="https://www.digitalocean.com/community/tutorials/how-to-install-the-apache-web-server-on-ubuntu-18-04" target="_blank" rel="noopener">How To Install the Apache Web Server on Ubuntu 18.04</a></p></li>
<li><p><a href="https://www.digitalocean.com/community/tutorials/how-to-secure-apache-with-let-s-encrypt-on-ubuntu-18-04" target="_blank" rel="noopener">How To Secure Apache with Let's Encrypt on Ubuntu 18.04</a></p></li>
<li><p><a href="https://www.digitalocean.com/community/tutorials/how-to-install-wordpress-with-lamp-on-ubuntu-18-04" target="_blank" rel="noopener">How To Install WordPress with LAMP on Ubuntu 18.04</a></p></li>
</ol>
<p>其中，最重要的是最后一篇文章，系统讲述了各类配置操作，前3篇都是铺垫</p>
<p>各个软件自动启动的设置参见了: <a href="https://zhuanlan.zhihu.com/p/55579024" target="_blank" rel="noopener">基于DigitalOcean+LAMP+WordPress搭建个人网站</a></p>
<p>目前，申请到的域名为<code>zhaoshihan.me</code>，可以在<strong>NameCheap</strong>和<strong>DigitalOcean</strong>上登陆并在<strong>domain-list</strong>中查看DNS-IPv4/IPv6的对应关系。这里我只用到了3个DNS Record，分别是A Record（用于IPv4地址）、AAAA Record（用于IPv6地址）、CNAME Record（用于www的host域名转发）。对于各类DNS地址的介绍可以参考<a href="https://www.ruanyifeng.com/blog/2016/06/dns.html" target="_blank" rel="noopener">DNS 原理入门</a>这篇文章。</p>
<h2 id="vps上创建git-hooks进行自动更新">VPS上创建Git Hooks进行自动更新</h2>
<p>Git Hooks简单来说就是Git为开发者提供的一个生命周期的钩子，方便我们定义在Git的某些规范操作（<code>git commit</code>，<code>git merge</code>，<code>git push</code>这样的）前后的自定义个人处理操作。还是DigitalOcean Community，<a href="https://www.digitalocean.com/community/tutorials/how-to-use-git-hooks-to-automate-development-and-deployment-tasks" target="_blank" rel="noopener">How To Use Git Hooks To Automate Development and Deployment Tasks</a>这篇文章介绍的非常清楚，看这一篇就足够了。简单来说就是只要我们创建自己的脚本，并将它起名为规定的<strong>Hook Name</strong>并赋予执行权限，就可以保证在相应的Git规范操作前后执行我们自定义的脚本。在这里我使用了<strong>post-receive</strong>脚本，放在了<code>/home/git/BlogGit/hooks</code>目录下面。这里的BlogGit只是项目名称，可以替换。以下是<strong>post-receive</strong>脚本的内容。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 这是我们自定义的一个脚本文件，</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 用途是在Hexo deploy上传到BlogGit时同步更新/var/www/zhaoshihan.me/Hexo下的文件</span></span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">GIT_REPO=/home/git/BlogGit</span><br><span class="line">PUBLIC_WWW=/var/www/zhaoshihan.me/Hexo</span><br><span class="line"></span><br><span class="line">git --work-tree=$&#123;PUBLIC_WWW&#125; --git-dir=$&#123;GIT_REPO&#125; checkout -f</span><br></pre></td></tr></table></figure>
<p>最后修改一下权限，使得<code>git</code>用户拥有更改<code>/var/www/zhaoshihan.me/Hexo</code>目录下内容的能力，这里我简单粗暴的将目录下的所有文件所属用户和用户组改为了<code>git</code>用户。</p>
<h2 id="主题美化和额外配置">主题美化和额外配置</h2>
<p>这一点完全看个人的需求。我在此主要参考了<a href="https://blog.mrzorg.top/Hexo/2020-02-12-hero-next-theme-settings/" target="_blank" rel="noopener">Hexo的Next主题美化设置</a>这篇文章，为Hexo添加了字数统计，阅读搜索，代码块样式等功能。这里需要注意下，Next 从v7.6版本以后不再维护auto_excerpt的功能，我使用了第三方的工具<a href="https://github.com/chekun/hexo-excerpt" target="_blank" rel="noopener">hexo-excerpt</a>进行了自动的配置，目前看应该是按段落行数截取的。</p>
<h2 id="日后的日常维护操作">日后的日常维护操作</h2>
<p>Hexo-cli常用的一些命令，<a href="https://hexo.io/zh-cn/docs/commands" target="_blank" rel="noopener">参见中文文档</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 发表一篇新文章的流程</span></span><br><span class="line">$ hexo new draft <span class="string">"文章名"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用本地server运行查看，默认访问网址为：http://localhost:4000/</span></span><br><span class="line">$ hexo server --draft</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将草稿文章添加到post中</span></span><br><span class="line"><span class="comment"># 也可以直接将_drafts文件夹中的文件直接手动移动到_posts文件夹中</span></span><br><span class="line">$ hexo publish <span class="string">"文章名"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成public静态文件</span></span><br><span class="line">$ hexo generate</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进行远程部署</span></span><br><span class="line">$ hexo deploy</span><br><span class="line"></span><br><span class="line"><span class="comment"># 特定情况下，需要进行清除操作</span></span><br><span class="line"><span class="comment"># 清除缓存文件 (db.json) 和已生成的静态文件 (public)</span></span><br><span class="line">$ hexo clean</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Apache</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/05/16/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="quick-start">Quick Start</h2>
<h3 id="create-a-new-post">Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="run-server">Run server</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="generate-static-files">Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="deploy-to-remote-sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>使用牛顿法解决开平方问题</title>
    <url>/2020/05/21/%E4%BD%BF%E7%94%A8%E7%89%9B%E9%A1%BF%E6%B3%95%E8%A7%A3%E5%86%B3%E5%BC%80%E5%B9%B3%E6%96%B9%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>这个问题的起因是我在做leetcode上的一道题延伸出来的，原题目是<a href="https://leetcode-cn.com/problems/sqrtx/" target="_blank" rel="noopener">Leetcode 69. Sqrtx</a>。不过这道题目还是做了很大的简化，它只让我们找出符合要求的整数解。在实际运算中，我们显然希望获得一个开平方的精确小数值，比如说像 <span class="math inline">\(\sqrt{2} = 1.414214, \sqrt{3} = 1.732051\)</span> 这个样子。这里就需要使用牛顿法来进行求解了。这也是目前计算机学科中进行开平方运算的标准方法。下面我就来详细说说对这一算法的分析。</p>
<h2 id="牛顿法的解题思路">牛顿法的解题思路</h2>
<p>牛顿法告诉我们：</p>
<p>假设方程<span class="math inline">\(f(x) = 0\)</span>在<span class="math inline">\(c\)</span>处有一个根，那么可以用以下这个迭代的式子： <span class="math display">\[
x_{n+1} = x_n - \frac{f(x_n)}{f&#39;(x_n)}
\]</span> 依次计算出<span class="math inline">\(x_1\)</span>，<span class="math inline">\(x_2\)</span>，<span class="math inline">\(x_3\)</span>......，如此数列将无限逼近于方程的根(<span class="math inline">\(c\)</span>)。</p>
<p>我们从几何意义上来理解牛顿法，会比较容易。根据点斜式，可以很轻松的写出在<span class="math inline">\((x_n, f(x_n))\)</span>处的切线方程为<span class="math inline">\(y = f&#39;(x_n) * (x - x_n) + f(x_n)\)</span>。递推式中的<span class="math inline">\(\frac{f(x_n)}{f&#39;(x_n)}\)</span>这一项，相当于是这个切线方程与<span class="math inline">\(x\)</span>轴相交后形成的直角三角形在<span class="math inline">\(x\)</span>轴上的距离。每次做这样的递推，就会越来越接近原函数<span class="math inline">\(f(x) = 0\)</span>的那个零点。</p>
<p>下面这张图很好的展示了这种数列逼近的效果:</p>
<p><img src="https://www.math24.net/wp-content/uploads/2019/04/calc1-newtons-method1b.svg" /></p>
<p>由此，我们就可以把牛顿法运用到开平方的运算中来了。对于求解<span class="math inline">\(\sqrt{a}\)</span>这个式子，相当于求解方程<span class="math inline">\(f(x) = x^2 - a = 0\)</span>。也就是函数<span class="math inline">\(f(x)\)</span>的零点。<span class="math inline">\(f(x)\)</span>的一阶导数可以写为<span class="math inline">\(f&#39;(x) = 2x\)</span>，这样，牛顿迭代式为： <span class="math display">\[
x_{n+1} = x_n - \frac{x_n^2 - a}{2x_n} = \frac{1}{2}(x_n + \frac{a}{x_n})
\]</span> 我们假设求解<span class="math inline">\(\sqrt{2}\)</span>，任意设置迭代的初值（非负数），比如为<span class="math inline">\(x_0 = 1\)</span>，带入上面的迭代式进行运算，可以得到： <span class="math display">\[
\begin{aligned}
&amp;x_0 = 1, \\
&amp;x_1 = \frac{1}{2} * (1 + \frac{2}{1}) = 1.5, \\
&amp;x_2 = \frac{1}{2} * (1.5 + \frac{2}{1.5}) = 1.41666, \\
&amp;x_3 = \frac{1}{2} * (1.41666 + \frac{2}{1.41666}) = 1.414216, \\
&amp;......
\end{aligned}
\]</span> 由此我们也可以写出相应的代码来快速的得到答案，下面是一个<a href="https://introcs.cs.princeton.edu/java/13flow/Sqrt.java.html" target="_blank" rel="noopener">Princeton大学</a>写的一个Java语言的版本：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用牛顿法解决开平方问题</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> EPSILON = <span class="number">1.0e-15</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">double</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> t = a;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (Math.abs(t - a / t) &gt; EPSILON * t) &#123;</span><br><span class="line">            t = (t + a / t) / <span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> a = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">new</span> Solution().sqrt(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于1e9+7的运算迭代结果如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">a = 1.000000007E9</span><br><span class="line">x[0] = 1000000007.00000000000000000000</span><br><span class="line">x[1] = 500000004.00000000000000000000</span><br><span class="line">x[2] = 250000003.00000000000000000000</span><br><span class="line">x[3] = 125000003.49999999000000000000</span><br><span class="line">x[4] = 62500005.74999991000000000000</span><br><span class="line">x[5] = 31250010.87499927400000000000</span><br><span class="line">x[6] = 15625021.43749418100000000000</span><br><span class="line">x[7] = 7812542.71870341100000000000</span><br><span class="line">x[8] = 3906335.35900220370000000000</span><br><span class="line">x[9] = 1953295.67670501510000000000</span><br><span class="line">x[10] = 976903.81598531710000000000</span><br><span class="line">x[11] = 488963.72911088780000000000</span><br><span class="line">x[12] = 245504.43529787744000000000</span><br><span class="line">x[13] = 124788.84074657578000000000</span><br><span class="line">x[14] = 66401.18893134680000000000</span><br><span class="line">x[15] = 40730.58017145583000000000</span><br><span class="line">x[16] = 32641.07897445094600000000</span><br><span class="line">x[17] = 31638.66067713355000000000</span><br><span class="line">x[18] = 31622.78069957933300000000</span><br><span class="line">x[19] = 31622.77671236376000000000</span><br><span class="line">x[20] = 31622.77671236351300000000</span><br><span class="line"></span><br><span class="line">Process finished with <span class="built_in">exit</span> code 0</span><br></pre></td></tr></table></figure>
<h2 id="牛顿法背后的数学原理">牛顿法背后的数学原理</h2>
<p>我们作为后人，当然可以直接使用400年前牛顿发明的这种算法而不假思索。但是，如果我们作为一个算法最初的设计者，就必须要想的更多一些，那就是：为什么这样做一定可以找到一个数的平方根呢？（从数学的角度来说，就是：满足上述递归条件的数列，是否一定收敛于函数<span class="math inline">\(f(x) = x^2 - a\)</span>的零点呢）只有先在数学上完成这样的证明，我们才有理由说这个算法是严谨有效的。下面我将给出两种对牛顿法正确性的数学证明。</p>
<p>第一种是英文版的维基百科<a href="https://en.wikipedia.org/wiki/Newton%27s_method" target="_blank" rel="noopener">Newton's method</a>词条中给出的证明，我简单用我理解的中文在此复述如下：</p>
<p>根据<a href="https://en.wikipedia.org/wiki/Taylor%27s_theorem" target="_blank" rel="noopener">泰勒定理</a>，任何函数<span class="math inline">\(f(x)\)</span>当它有连续的二阶导数时，那么靠近函数<span class="math inline">\(f(x)\)</span>零点（我们假设为<span class="math inline">\(\alpha\)</span>，<span class="math inline">\(\alpha = \sqrt{a}\)</span>）的点都可以写为泰勒展开式如下： <span class="math display">\[
f(\alpha) = f(x_n) + f&#39;(x_n)(\alpha - x_n) + R_1
\]</span> 在此，泰勒级数展开式的拉格朗日余项为： <span class="math display">\[
R1 = \frac{1}{2!}f&#39;&#39;(\xi_n)(\alpha - x_n)^2
\]</span> 这里的<span class="math inline">\(\xi_n\)</span>在<span class="math inline">\(x_n ～ \alpha\)</span>的范围内，因为<span class="math inline">\(\alpha\)</span>是函数的一个根，所以上面的泰勒展开式相当于: <span class="math display">\[
\begin{aligned}
&amp;0 = f(\alpha) = f(x_n) + f&#39;(x_n)(\alpha - x_n) + \frac{1}{2!}f&#39;&#39;(\xi_n)(\alpha - x_n)^2 \\
\Leftrightarrow \quad &amp;\frac{f(x_n)}{f&#39;(x_n)} + (\alpha - x_n) = \frac{-f&#39;&#39;(\xi_n)}{2f&#39;(x_n)}(\alpha - x_n)^2
\end{aligned}
\]</span> 由于我们定义了数列<span class="math inline">\(\lbrace x_n \rbrace\)</span>的递推式为<span class="math inline">\(x_{n+1} = x_n - \frac{f(x_n)}{f&#39;(x_n)}\)</span> ，因此上式可以写为： <span class="math display">\[
\begin{aligned}
\underbrace{\alpha - x_{n+1}}_{\epsilon_{n+1}}
 &amp;= \frac{-f&#39;&#39;(\xi_n)}{2f&#39;(x_n)}(\underbrace{\alpha - x_n}_{\epsilon_n})^2 \\
\Leftrightarrow \quad \epsilon_{n+1} &amp;= \frac{-f&#39;&#39;(\xi_n)}{2f&#39;(x_n)} \cdot \epsilon_n^2
\end{aligned}
\]</span> 根据数列极限的定义，我们定义<span class="math inline">\(\epsilon_n = \alpha - x_n\)</span>，对于上式两边取绝对值，有： <span class="math display">\[
\begin{aligned}
|\epsilon_{n+1}| &amp;= \frac{|f&#39;&#39;(\xi_n)|}{2|f&#39;(x_n)|} \cdot |\epsilon_n|^2 \\
\Leftrightarrow \quad \frac{|\epsilon_{n+1}|}{|\epsilon_n|} &amp;= \underbrace{\frac{|f&#39;&#39;(\xi_n)|}{2|f&#39;(x_n)|}}_{M} \cdot |\epsilon_n|
\end{aligned}
\]</span> 对于函数<span class="math inline">\(f(x) = x^2 - a\)</span>，我们可以得到函数的一阶导数为<span class="math inline">\(f&#39;(x) = 2x\)</span>，函数的二阶导数为<span class="math inline">\(f&#39;&#39;(x) = 2\)</span></p>
<p>此时，上式中的<span class="math inline">\(M\)</span>项可以写为： <span class="math display">\[
M = \frac{1}{2} \cdot \frac{|2|}{|2x_n|} = \frac{1}{2|x_n|}
\]</span> 由此，可以得到整个右式： <span class="math display">\[
\begin{split}
M \cdot |\epsilon_n| &amp;= \frac{1}{2|x_n|} \cdot |x_n - \alpha| \\
&amp;= \frac{1}{2} \cdot \Bigg| \frac{x_n - \alpha}{x_n} \Bigg| \\
&amp;= \frac{1}{2} \cdot \bigg| 1 - \frac{\alpha}{x_n} \bigg| 
\end{split}
\]</span> 对于任意的正数<span class="math inline">\(x_n\)</span>，<span class="math inline">\(\alpha\)</span>，能够得到整个右式<span class="math inline">\(M \cdot |\epsilon_n| &lt; 1\)</span>，因此数列一定收敛。</p>
<p>第二种证明是我和高中同学刘浩（不愧是考研的人，数学就是比我好...）讨论的方法，更加简单易懂一些:</p>
<p>需要用到一个简单的推论： <span class="math display">\[
\begin{aligned}
\forall a, b \in R^+, \quad (a + b)^2 &amp;\ge 4ab \\
\Rightarrow \ \frac{1}{4}(a + b)^2 &amp;\ge ab \\
\Rightarrow \ \frac{1}{2}(a + b) &amp;\ge \sqrt{ab}
\end{aligned}
\]</span></p>
<p>此时， <span class="math display">\[
\begin{aligned}
x_{n+1} &amp;= \frac{1}{2}(x_n + \frac{a}{x_n}) \\
&amp;\ge \sqrt{x_n \cdot \frac{a}{x_n}} = \sqrt{a}
\end{aligned}
\]</span> 也就是说，我们证明了对数列中的任意一项<span class="math inline">\(x_n\)</span>(除了初始值<span class="math inline">\(x_0\)</span>由用户规定外)都有<span class="math inline">\(x_n \ge \sqrt{a}\)</span>，因此我们得到以下的不等式恒成立： <span class="math display">\[
\begin{gather*}
\frac{a}{x_n} \le \frac{a}{\sqrt{a}} = \sqrt{a} \le x_n \\
x_{n+1} = \frac{1}{2}(x_n + \frac{a}{x_n}) \le \frac{1}{2}(x_n + x_n) = x_n
\end{gather*}
\]</span> 即我们证明了数列<span class="math inline">\(\lbrace x_n \rbrace\)</span>单调递减并且有下界<span class="math inline">\(\sqrt{a}\)</span>，根据单调有界必有极限的定理（<a href="https://en.wikipedia.org/wiki/Monotone_convergence_theorem" target="_blank" rel="noopener">Monotone convergence theorem</a>），可以证明这一递推数列收敛于<span class="math inline">\(\sqrt{a}\)</span></p>
<p>令<span class="math inline">\(x_{n+1} = x_n = \sqrt{a}\)</span>带入检验，发现递推式成立： <span class="math display">\[
\begin{aligned}
&amp;左式 = x_{n+1} = \sqrt{a} \\
&amp;右式 = \frac{1}{2}(x_n + \frac{a}{x_n}) = \frac{1}{2}(\sqrt{a} + \frac{a}{\sqrt{a}}) = \sqrt{a}
\end{aligned}
\]</span></p>
<h2 id="牛顿法的算法复杂度">牛顿法的算法复杂度</h2>
<p>在第一种证明的时候，我们可以看到牛顿法的收敛速度是平方级别的：<span class="math inline">\(|\epsilon_{n+1}| \le M \cdot |\epsilon_n|^2\)</span>。因此它的算法复杂度可以这样来表示<span class="math inline">\(O(\log{n} \cdot F(n))\)</span>，这里的<span class="math inline">\(F(n)\)</span>是我们在计算迭代式中<span class="math inline">\(\frac{f(x)}{f&#39;(x)}\)</span>这一项时需要的n位精确度的开销。这里参见了维基百科中<a href="%5Bhttp://en.citizendium.org/wiki/Newton%27s_method#Computational_complexity%5D(http://en.citizendium.org/wiki/Newton&#39;s_method#Computational_complexity)">Newton's method</a>这一词条的内容。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>学习计算机科学的方法论</title>
    <url>/2020/06/07/%E5%AD%A6%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E7%9A%84%E6%96%B9%E6%B3%95%E8%AE%BA/</url>
    <content><![CDATA[<p>计算机科学（Computer Science，以下简称CS）包罗万象，博大精深。由于是一门操作性极强且又极为复杂的学科，因此对新手并不友好。我个人从大学四年的专业学习上，只能说是积累了一点经验，打下了一点基础。我就在此谈一谈个人对于学习计算机科学的方法论，为接下来自己的自学提高指明一个方向。</p>
<p>我把自我的学习简单分为以下几种形式，缺一不可。</p>
<h2 id="看书">看书</h2>
<p>我想把看书作为一个最重点的内容来谈。很多程序员觉得网络是必不可少的工具，因而过分的重视网络上的信息获取，反而轻视了书本阅读。我自己也在很长的一段时间内犯过这样的错误。事实上，书籍阅读的学习是十分体系化的，一本好书往往能帮助个人建立起整个知识体系结构，打通各个知识点之间的关联与互动，这些内容是自己通过零碎的网络信息获取所不能得到的。而且，网络上的资源参差不齐，许多说法互相矛盾，还要大部分都是抄袭、转载、浮于表面的东西。如果你愿意并且手边有质量高的书籍的话，你会发现很多几篇大段文章都说不清楚的概念，在书本上寥寥几句话就说明白了。</p>
<p>如何选择书籍是一门学问。我觉得就个人的经验来说，在决定阅读或购买一本技术书之前，在<code>豆瓣</code>上进行评分查看是个不错的选择。一般来说评分在<code>8.0</code>以上的都是用心写了的，有一定的可取之处，可以作为免费借阅的书籍选择。在<code>9.0</code>分之上的大部分情况下可以考虑直接购买，不会有太大的问题。另外，技术书籍是<strong>买新不买旧</strong>的，追求<code>3-5</code>年内的最新版本往往来说是最贴合当下的，没有过时的技术。我个人觉得外国人写书还是比中国人写书要好一些，但是外国书有个很大的问题就是翻译问题，这个直接影响到最终的阅读体验，所以一定要注意<code>豆瓣</code>下面关于书籍翻译质量的评论。图灵书的翻译质量是最高的，其次是异步图书、动物书、人物书也可以，华章和黑皮的机械工业书翻译质量参差不齐，需要仔细鉴别一下。<strong>在现阶段，自己不宜也不要去直接挑战英文版的书籍阅读，无谓的增加学习难度并且极有可能半途而废</strong>。</p>
<p>最后说一个个人目前新的想法：<strong>那就是高质量的书籍还是买回来看好</strong>，这里所说的，就是纯粹为了个人兴趣学习的目的，不是为了一时完成作业、查阅一个小知识点这种零碎的学习。虽然中国有话说<strong>书非借不能读</strong>，但是借书的话在阅读的过程中有太多限制，不能自由的划重点、做批注这样。技术书的阅读是非常枯燥的，如果不通过这些方式调动自己积极主动的思考，那极大可能是看不下去整本书的。最后，中国的国情是书籍都很便宜，哪怕是特别厚的技术书也不过100块左右。所以说，<strong>只要是好书，买回来并且认真看完了，就只赚不赔</strong>。</p>
<h2 id="动手实践">动手实践</h2>
<p>动手实践和理论学习对于CS学科是同等重要的。一个人要是十天半月不写代码，那么他的代码能力绝对是会下降的。一个完整的项目，或者一个优质的课程作业，需要从最初的环境配置做起，到整体设计、代码实现、调试和试错，最后进行部署或发布，牵涉到了方方面面的内容。<strong>很多之前看到过的似是而非、没有完全理解和掌握的知识点，都是在动手实践中才能加深理解的</strong>。要知道整个CS学科是一门立足实践的科学，所有的概念和算法都有与之对应的代码负责具体的实现。<strong>Talk is cheap. Show me the code！</strong></p>
<p>自己在动手实践上目前存在着非常大的不足之处，最近一两年来都没有什么大的、好的项目可以拿的出手。这是接下来一段时间内在看书学习之余需要着力提高的一个地方。</p>
<h2 id="网络资源">网络资源</h2>
<p>许多的程序员都是<strong>面向网络编程</strong>的，这一点我们在初级阶段是无法回避的问题。希望有朝一日自己可以闭门造车还能写出高质量的代码，那就真的是达到极高的水平了。网络资源十分丰富：从文章帖子、文档手册、视频教程再到Github代码仓库一应俱全。就文章而言，我觉得最权威、最可信的莫过于官方的开发文档，其次是<code>StackOverflow</code>、<code>SegmentFault</code>这样的高质量网站或<code>DigitalOcean Community</code>这种开源社区的文章，再其次是一些个人搭建的博客和<code>知乎</code>、<code>掘金</code>、<code>简书</code>这样的博客平台或<code>腾讯云</code>，<code>美团</code>这样的开发者团队文章，最后是<code>CSDN</code>以及各种其他不入流网站。</p>
<p><code>Coursera</code>上有很多课程很值得一学，这也是自己接下来要努力学习的一个方向。我想多说一句，就是做一件事情就要把它做到最好。一个人的水平有高低，反映到成果上就是有高下之分，但是态度是同样重要的。为了知识而学，而不是为了证书而学，课程作业是和教学视频同等重要的，需要认真对待，不到万不得已不可随意抄袭别人。</p>
<h2 id="源码阅读">源码阅读</h2>
<p>这是提高自己代码能力的又一条重要途径。目前实践的不多，暂时按下不表。但是，那些优秀的代码框架、轮子、库函数都是前任编程设计的智慧，都用代码的形式展示给自己了。一个只会调用而从来不去研究源码的程序员，就是只懂实现而不懂原理，他对编程的理解和掌握度就永远是低层次的。</p>
<h2 id="同行和同辈的交流">同行和同辈的交流</h2>
<p>这个是我在大学四年中一直没有做的很好的地方。我深感身边很多人太难沟通和交流，三观不合，因而人际关系处理得极为不好。但是，同辈的交流促进就CS学习来说是十分重要的。一个人是不能闭门造车的学习的，至少要对身边人的学习研究的方向有个大概的认识了解，对行业的发展有个了解。这就需要结识那些真正热爱技术，不断潜心钻研的人。但是，真的好难啊！不是说大学没有这样的人，而是说这样的人太难接触，更难以跟自己结交朋友：不是过于狂傲看不起人，就是沉默木讷不言。将来读研期间换个环境再着力吧。</p>
<p>身边人能给带来的益处是很多的：<strong>从直接的手把手教学、优秀工具的使用、项目的设计到个人看法和习惯的改变</strong>。虽然大学期间的诸多团队合作项目体验不好，但是我还是对这方面抱有期待。不应该因为有人投机取巧，就不相信有踏实肯干的人；不应该因为有人急功近利，就不相信有纯粹热爱的人；不应该因为有人狂傲不羁，就不相信有乐于分享的人。</p>
<h2 id="论文阅读">论文阅读</h2>
<p>目前对这方面涉及不多，所以暂时按下不表。我只记得谁说过一句话：一个行业内最新的成果、最新的发展趋势，肯定是看这个方向上的学术论文，如果说已经出了书籍了，那就已经过时了。将来走科研路线的话，这真的是要下大力气的地方。</p>
]]></content>
      <categories>
        <category>感悟</category>
      </categories>
      <tags>
        <tag>方法论</tag>
      </tags>
  </entry>
</search>
