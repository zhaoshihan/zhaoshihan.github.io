<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++ const关键字辨析</title>
    <url>/posts/35148/</url>
    <content><![CDATA[<p>最近学习C/C++语言，又一次看到了<code>const</code>关键字。之前本科的时候这个地方就一直没有搞的很明白，这次我想专门写篇文章来帮助自己记忆。以下的内容参考《C++ Primer》（第五版）</p>
<p>首先，我们要明确：C++语言的类型（Type）分为两种：一种叫做普通类型（Primitive Build-in Type）；一种叫做复合类型（Compound Type），const关键字对于这两种类型的作用效果是不一样的</p>
<p>由于C++的编译过程是各个文件分开的（separate compilation），所以需要一点概念辨析：</p>
<p><strong>变量（Variable）就是有名称（name）的对象（Object）；一个Object就是有类型（type）的一定量的内存空间</strong></p>
<p>什么是变量声明（declaration）？就是明确指出变量的类型（Type）和名称（name）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> i; <span class="comment">// declares, but does not define i</span></span><br><span class="line"># 这里的变量i一般是通过<span class="meta">#<span class="meta-keyword">include</span>引用的来自其他文件中定义的变量</span></span><br><span class="line"># 一般情况下，一个变量可以声明多次，但是只能定义一次，最常见的例子就是<span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="built_in">std</span>::<span class="built_in">cin</span>（<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;），它在&lt;iostream&gt;文件中被定义，但是可以被各个文件include并声明使用</span></span></span><br></pre></td></tr></table></figure>
<p>什么是变量定义（definition）？就是明确指出变量的类型（Type）和名称（name），同时分配内存空间，有可能伴随着变量的初始化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> j; <span class="comment">// declares and defines j</span></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>; <span class="comment">// declares, define, initialize</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">double</span> pi = <span class="number">3.1416</span> <span class="comment">// definition</span></span><br><span class="line"># 当声明（declaration）伴随着显式地初始化（initialize）时，同样也是一种变量的定义（definition）</span><br><span class="line"># 此时，相当于覆盖了<span class="keyword">extern</span>关键字的意义（<span class="keyword">override</span>）</span><br></pre></td></tr></table></figure>
<p><strong>一个变量可以声明多次，但是只能定义一次</strong></p>
<p>什么是变量初始化（initialize）？就是说变量在创建（created，分配了内存空间）的同时获得指定的值（specified value）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> units_sold = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">units_sold</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta"># new standard</span></span><br><span class="line"><span class="keyword">int</span> units_sold = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> units_sold&#123;<span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>对于我们自定义的Class Type，变量在没有显式声明的情况下会进行默认初始化（default initialized）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> str; <span class="comment">// str implicitly initialized to the empty string, 这是由std::string class定义的</span></span><br><span class="line">Sales_item item; <span class="comment">// default-initialized Sales_item object</span></span><br></pre></td></tr></table></figure>
<p>对于Primitive Build-in Type，分为两种情况来说：如果这个build-in type的变量是在所有函数体之外定义（define）的，那么会被默认初始化为0；如果这个build-in type的变量是在函数体内部被定义的，那么值就是<code>undefined</code></p>
<p>什么是变量赋值（assignment）？就是说将变量当前的值（current value）擦除，替换成新的值，通常使用<code>=</code></p>
<p><strong>在C++中，初始化（initialize）和赋值（assign）是完全不同的两个概念</strong></p>
<h2 id="const-primitive-type">Const Primitive Type</h2>
<p>普通类型（Primitive Build-in Type）包括了以下这些：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Type</th>
<th style="text-align: center;">Meaning</th>
<th style="text-align: center;">Minimum Size</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">bool</td>
<td style="text-align: center;">Boolean</td>
<td style="text-align: center;">NA</td>
</tr>
<tr class="even">
<td style="text-align: center;">char</td>
<td style="text-align: center;">Character</td>
<td style="text-align: center;">8 bits</td>
</tr>
<tr class="odd">
<td style="text-align: center;">wchar_t</td>
<td style="text-align: center;">Wide character</td>
<td style="text-align: center;">16 bits</td>
</tr>
<tr class="even">
<td style="text-align: center;">char16_t</td>
<td style="text-align: center;">Unicode character</td>
<td style="text-align: center;">16 bits</td>
</tr>
<tr class="odd">
<td style="text-align: center;">char32_t</td>
<td style="text-align: center;">Unicode character</td>
<td style="text-align: center;">32 bits</td>
</tr>
<tr class="even">
<td style="text-align: center;">short</td>
<td style="text-align: center;">short integer</td>
<td style="text-align: center;">16 bits</td>
</tr>
<tr class="odd">
<td style="text-align: center;">int</td>
<td style="text-align: center;">Integer</td>
<td style="text-align: center;">16 bits</td>
</tr>
<tr class="even">
<td style="text-align: center;">long</td>
<td style="text-align: center;">long integer</td>
<td style="text-align: center;">32 bits</td>
</tr>
<tr class="odd">
<td style="text-align: center;">long long</td>
<td style="text-align: center;">long integer</td>
<td style="text-align: center;">64 bits</td>
</tr>
<tr class="even">
<td style="text-align: center;">float</td>
<td style="text-align: center;">Single-precision floating-point</td>
<td style="text-align: center;">6 significant digits</td>
</tr>
<tr class="odd">
<td style="text-align: center;">double</td>
<td style="text-align: center;">Double-precision floating-point</td>
<td style="text-align: center;">10 significant digits</td>
</tr>
<tr class="even">
<td style="text-align: center;">long double</td>
<td style="text-align: center;">Extended-precision floating-point</td>
<td style="text-align: center;">10 significant digits</td>
</tr>
</tbody>
</table>
<p>作用于普通类型上的<code>const</code>关键字很容易理解，就是说这个类型的Object的值不能改变（不能被反复多次赋值，assignment）。因此我们规定，一个<code>const</code>的object在定义（define）的时候就必须完成初始化（initialized），并且在以后的生命过程中不能被赋值（assignment）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> i = <span class="number">42</span>; <span class="comment">// ok, initialized at compile time</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> j = get_size(); <span class="comment">// ok, initialized at run time</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> k; <span class="comment">// error, k is uninitialized const</span></span><br><span class="line">....</span><br><span class="line">i = <span class="number">100</span>; <span class="comment">// 对于const的object进行赋值操作是错误的</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = i; <span class="comment">// ok, the value in i is copied into ci</span></span><br><span class="line"><span class="keyword">int</span> j = ci;	<span class="comment">// ok, the value in ci is copied into j</span></span><br></pre></td></tr></table></figure>
<h2 id="const-reference-type">Const Reference Type</h2>
<p>复合类型（Compound Type）主要包括了两种，一种是引用（Reference）；一类种是指针（Pointer）。我们这里先考虑<code>const</code>关键字对于引用的影响。</p>
<p>首先，我们要明确一点：引用（Reference）不是一种Object（因此也就没有内存地址，不能通过<code>&amp;</code>取地址符号获得内存地址），它只是某个Object的一个别名（Alias）。不管前面有没有加<code>const</code>关键字，引用本身都具有以下几个特点：</p>
<ul>
<li><p>引用在定义的同时就必须要初始化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ival = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;refVal = ival; <span class="comment">// refVal refers to (is another name for) ival</span></span><br><span class="line"><span class="keyword">int</span> &amp;refVal2; <span class="comment">// error, a reference must be initialized</span></span><br></pre></td></tr></table></figure></li>
<li><p>引用在经过初始化之后，就不会再绑定（rebind）其他的Object</p></li>
<li><p>当完成初始化后，所有对引用的操作就是对引用所绑定的那个Object的操作</p></li>
<li><p>因为引用需要绑定Object，而引用自己本身不是Object，所以不存在多重引用（reference that refer to a reference）</p></li>
</ul>
<p>在以上的情况下，我们来说明<code>const</code>关键字对引用变量的影响：</p>
<p>在引用定义/初始化时，在Type前面加入<code>const</code>（reference to const），<strong>它表示在之后的程序中，不能通过这个引用来修改（这个引用所绑定的）Object的值</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r1 = ci; <span class="comment">// ok, both reference and underlying object are const</span></span><br><span class="line">r1 = <span class="number">42</span>; <span class="comment">// error, r1 is a reference to const</span></span><br><span class="line"><span class="keyword">int</span> &amp;r2 = ci; <span class="comment">// error, non const reference to a const object</span></span><br></pre></td></tr></table></figure>
<p>因此，第一，对于一个本身已经是<code>const</code>的Object来说，不能使用没有（前面加）<code>const</code>的引用类型来绑定；第二，<strong>尽管不能通过这个引用来修改绑定的Object，但是可以通过其他的方式修改Object的值</strong>（所以说，<code>const</code>Type的引用可以绑定非<code>const</code>类型的Object）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r1 = i; <span class="comment">// we can bind a const int&amp; to a plain int object</span></span><br><span class="line"><span class="keyword">int</span> &amp;r2 = i; <span class="comment">// also okay</span></span><br><span class="line">r1 = <span class="number">0</span>; <span class="comment">// error, r1 is a reference to const</span></span><br><span class="line">i = <span class="number">0</span>; <span class="comment">// ok, 直接通过赋值改变Object的值</span></span><br><span class="line">r2 = <span class="number">0</span>; <span class="comment">// ok, r2 is not const, i is now 0, 或者通过其他引用来修改Object的值</span></span><br></pre></td></tr></table></figure>
<h2 id="const-pointer-type">Const Pointer Type</h2>
<p>首先，先说指针本身，它自己也是一个Object，指针里存储的值是它所指向的那个Object的地址（address）</p>
<ul>
<li>指针在定义时不一定要初始化</li>
<li>指针存储的是它指向/绑定的那个Object的地址</li>
<li>指针在完成初始化之后依然可以绑定赋值（指向）为其他的Object</li>
<li>对指针来说，解引用操作意味着返回指针指向的Object</li>
</ul>
<p>接下来考虑最复杂的情况，<code>const</code>关键字对于指针的影响</p>
<p>首先，和引用类型一样，指针可以被定义为指向const Object的指针。此时，<strong>同样不会保证这个指针指向的Object不会发生改变，只是能保证不能通过这个指针来改变Object的值</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> num = <span class="number">1.0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">double</span> *ptr = &amp;pi; <span class="comment">// error, ptr is a plain pointer</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *cptr = &amp;pi; <span class="comment">// ok, cptr may point to a double that is const</span></span><br><span class="line">cptr = &amp;num; <span class="comment">// 同样是可以的，这是因为对于指针cptr来说，const属于low-level, low-level non-const可以赋值给low-level const</span></span><br><span class="line">*cptr = <span class="number">42</span>; <span class="comment">// error, cannot assign to *cptr</span></span><br></pre></td></tr></table></figure>
<p>此外，指针由于自己本身也是一个Object，因此可以定义自身是<code>const</code>的指针，此时，这个<code>const</code>的指针<strong>必须在定义时完成初始化，并且一旦完成初始化后，指针的值（指向的Object的地址）将不能发生改变</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> errNumb = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> curErr = &amp;errNumb; <span class="comment">// curErr will always point to errNumb</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14159</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *<span class="keyword">const</span> pip = &amp;pi; <span class="comment">// pip is a const pointer to a const Object(double), 这里对于声明，需要从右往左来读</span></span><br></pre></td></tr></table></figure>
<p>如果一个Object自身被定义为<code>const</code>，那么我们称这种<code>const</code>为<strong>top-level const</strong>; 如果一个指针/引用指向/绑定了一个<code>const</code>的Object，那么我们称这样的<code>const</code>为<strong>low-level const</strong></p>
<p>对于赋值/拷贝操作来说（<code>=</code>），因为拷贝一个Object不会改变被拷贝的那个Object，所以<code>=</code>左右两边的Object（左边：被赋值的Object；右边：被拷贝的Object）是否是<strong>top-level const</strong>无关紧要</p>
<p>但是，对于<strong>low-level const</strong>来说就不同了，<code>=</code>两边的Object要么具有相同的low-level const（要么都声明为const，要么都不是const）；或者也可以把不是<code>const</code>的向<code>const</code>转化。但是，不能把<code>const</code>赋值给不是<code>const</code>的变量</p>
<p>对于引用来说，由于天然地自带了top-level const，因此是否定义为<code>const</code>其实就是是否定义为low-level const</p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/posts/16107/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="quick-start">Quick Start</h2>
<h3 id="create-a-new-post">Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="run-server">Run server</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="generate-static-files">Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="deploy-to-remote-sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>使用Hexo搭建个人博客（VPS+Git+Apache2）</title>
    <url>/posts/24212/</url>
    <content><![CDATA[<p>长期以来购买的国外VPS只是在进行代理转发的服务，然而现在DigitalOcean的最低价格的服务器配置也相当可以了。因此最近想来再多利用一下花钱买到的资源，就有了搭建个人博客的想法。希望能通过这种方式，同时勉励一下自己养成学习记录的好习惯吧。（CS知识真的是博大精深，有时候看一遍过段时间就忘了）</p>
<p>我使用的是Hexo框架搭建的博客。它的好处是可以直接<strong>在服务端部署静态的网站</strong>，本地打包上传，相比于WordPress这种主流框架来说，更加轻量级一些。</p>
<p>整个的框架流程是这样的：本地的Hexo分为源代码和<code>generate</code>后的静态文件两部分；Hexo源代码放在GitHub上进行托管（<code>.git</code>与远端连接）；本地的静态文件（<code>.deploy_git</code>）与VPS上的Git仓库连接（<code>/home/git</code>），最后再通过Git Hooks更新到Apache2的服务目录下（<code>/var/www</code>）</p>
<figure>
<img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gexv2xfxowj30uf0cwwfg.jpg" alt="博客流程图" /><figcaption aria-hidden="true">博客流程图</figcaption>
</figure>
<p>整个搭建过程最主要参考了<a href="http://paranoth.com/2017/10/29/Hexo%E5%BB%BA%E7%AB%99%E8%AE%B0%E5%BD%95/">Hexo建站记录(VPS+git+apache2)</a>这篇文章，在一些细节上稍有不同。</p>
<p>个人的服务器是Ubuntu 18.04的版本，本地电脑是Mac OS。</p>
<h2 id="本地端搭建hexo">本地端搭建Hexo</h2>
<p>这里的搭建过程按照<a href="https://mupceet.com/2019/08/build-blog-based-on-hexo/">Hexo 博客搭建与主题配置（零基础版）</a>来就可以了，只用看文章的前半部分。以上操作全部在PC端本地完成。需要注意的是，这里的Node.js版本不要使用最新的v14（我使用的是<code>v13.1.0</code>），否则在使用<code>npm</code>安装<code>hexo-cli</code>时会有莫名其妙的错误。</p>
<p>对于Hexo的配置（主要是<code>_config.yml</code>）和基础命令，可以查看<a href="https://hexo.io/zh-cn/docs/">Hexo的官方文档</a>来进行了解。这里吐槽一下，文档写的不怎么样，但是了解一下基础还是可以的。</p>
<p>我不是很喜欢Hexo自带的Landscape主题。这里我搭建的Hexo使用Next.Pisces主题，当时第一次看到这个主题的博客网页就非常喜欢，就用它了！</p>
<p>主要参考了这篇文章：<a href="https://sjq597.github.io/2018/05/15/Hexo%E4%BD%BF%E7%94%A8next-Pisces%E4%B8%BB%E9%A2%98/">Hexo使用next.Pisces主题</a></p>
<p>以及Next主题的<a href="https://github.com/theme-next/hexo-theme-next">Github源码</a></p>
<h2 id="配置vps的git仓库">配置VPS的Git仓库</h2>
<p>这里我在Ubuntu上新创建了一个名为<code>git</code>的用户，远程代码仓库放在了<code>/home/git/BlogGit</code>下。在笔记本本地项目HexoBlog中的<code>_config.yml</code>配置文件里，可以查看deploy的配置。</p>
<p>与远程服务器的连接通信，需要生成SSH的密钥，这里<a href="https://www.ssh.com/ssh/keygen/">SSH官网</a>上说的很清楚。我使用的是ECDSA的521位的密钥算法，相比于RSA 2048位，4096位的算法更为安全一些，也是目前推荐使用的新密钥算法。在使用<code>ssh-copy-id</code>命令向服务器上的<code>/home/git/authorized_keys</code>文件中传递公钥时，需要注意设置<code>sshd_config</code>的<strong>PasswordAuthentication</strong>为<strong>yes</strong>，之后再改回来。这里参考了<a href="https://www.digitalocean.com/community/questions/ssh-copy-id-not-working-permission-denied-publickey">ssh-copy-id not working Permission denied (publickey)</a>问题下面的回答。</p>
<p>对于使用SSH进行<code>命令行选项</code>或<code>用户配置文件</code>的方式进行连接，<a href="https://daemon369.github.io/ssh/2015/03/21/using-ssh-config-file">使用 SSH config 文件</a>这篇文章说的比较清楚。简而言之，使用命令行和使用用户配置文件的方式是可以等价互换的。我使用的是<code>用户配置文件的</code>方式，这样在之后的命令中更为方便一些。配置文件config在本地Mac OS上的<code>/Users/zsh/.ssh</code>目录下，上面有详细的注释。</p>
<h2 id="配置vps的apache2相关">配置VPS的Apache2相关</h2>
<p>由于最初自己在搭建服务器的时候使用的是LAMP+WordPress的模式，所以基本上所有和Apache2服务器有关的坑几乎都踩过一遍了。一般来说，按照教程来是没有问题的。这里我想特别推荐一下DigitalOcean Community中的有关教程，是在是太友好了，让我这个什么都不懂的人也能比较规范的来进行服务器的搭建操作。为此每个月使用DigitalOcean花5刀维持服务器我也愿意！下面就简单说一下当时的一些操作，以及事后需要注意维护的地方。</p>
<p>使用namecheap申请注册免费域名，和DigitalOcean建立联系，主要参考了：</p>
<p><a href="https://www.jianshu.com/p/b0fa42218ae6">在namecheap申请域名并在digitalocean中对该域名进行绑定</a></p>
<p>对DigitalOcean服务器droplet的操作，这里主要参考了以下几篇文章：</p>
<ol type="1">
<li><p><a href="https://www.digitalocean.com/community/tutorials/how-to-install-mysql-on-ubuntu-18-04">How To Install MySQL on Ubuntu 18.04</a></p></li>
<li><p><a href="https://www.digitalocean.com/community/tutorials/how-to-install-the-apache-web-server-on-ubuntu-18-04">How To Install the Apache Web Server on Ubuntu 18.04</a></p></li>
<li><p><a href="https://www.digitalocean.com/community/tutorials/how-to-secure-apache-with-let-s-encrypt-on-ubuntu-18-04">How To Secure Apache with Let's Encrypt on Ubuntu 18.04</a></p></li>
<li><p><a href="https://www.digitalocean.com/community/tutorials/how-to-install-wordpress-with-lamp-on-ubuntu-18-04">How To Install WordPress with LAMP on Ubuntu 18.04</a></p></li>
</ol>
<p>其中，最重要的是最后一篇文章，系统讲述了各类配置操作，前3篇都是铺垫</p>
<p>各个软件自动启动的设置参见了: <a href="https://zhuanlan.zhihu.com/p/55579024">基于DigitalOcean+LAMP+WordPress搭建个人网站</a></p>
<p>目前，申请到的域名为<code>zhaoshihan.me</code>，可以在<strong>NameCheap</strong>和<strong>DigitalOcean</strong>上登陆并在<strong>domain-list</strong>中查看DNS-IPv4/IPv6的对应关系。这里我只用到了3个DNS Record，分别是A Record（用于IPv4地址）、AAAA Record（用于IPv6地址）、CNAME Record（用于www的host域名转发）。对于各类DNS地址的介绍可以参考<a href="https://www.ruanyifeng.com/blog/2016/06/dns.html">DNS 原理入门</a>这篇文章。</p>
<h2 id="vps上创建git-hooks进行自动更新">VPS上创建Git Hooks进行自动更新</h2>
<p>Git Hooks简单来说就是Git为开发者提供的一个生命周期的钩子，方便我们定义在Git的某些规范操作（<code>git commit</code>，<code>git merge</code>，<code>git push</code>这样的）前后的自定义个人处理操作。还是DigitalOcean Community，<a href="https://www.digitalocean.com/community/tutorials/how-to-use-git-hooks-to-automate-development-and-deployment-tasks">How To Use Git Hooks To Automate Development and Deployment Tasks</a>这篇文章介绍的非常清楚，看这一篇就足够了。简单来说就是只要我们创建自己的脚本，并将它起名为规定的<strong>Hook Name</strong>并赋予执行权限，就可以保证在相应的Git规范操作前后执行我们自定义的脚本。在这里我使用了<strong>post-receive</strong>脚本，放在了<code>/home/git/BlogGit/hooks</code>目录下面。这里的BlogGit只是项目名称，可以替换。以下是<strong>post-receive</strong>脚本的内容。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 这是我们自定义的一个脚本文件，</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 用途是在Hexo deploy上传到BlogGit时同步更新/var/www/zhaoshihan.me/Hexo下的文件</span></span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">GIT_REPO=/home/git/BlogGit</span><br><span class="line">PUBLIC_WWW=/var/www/zhaoshihan.me/Hexo</span><br><span class="line"></span><br><span class="line">git --work-tree=$&#123;PUBLIC_WWW&#125; --git-dir=$&#123;GIT_REPO&#125; checkout -f</span><br></pre></td></tr></table></figure>
<p>最后修改一下权限，使得<code>git</code>用户拥有更改<code>/var/www/zhaoshihan.me/Hexo</code>目录下内容的能力，这里我简单粗暴的将目录下的所有文件所属用户和用户组改为了<code>git</code>用户。</p>
<h2 id="主题美化和额外配置">主题美化和额外配置</h2>
<p>这一点完全看个人的需求。我在此主要参考了<a href="https://blog.mrzorg.top/Hexo/2020-02-12-hero-next-theme-settings/">Hexo的Next主题美化设置</a>这篇文章，为Hexo添加了字数统计，阅读搜索，代码块样式等功能。这里需要注意下，Next 从v7.6版本以后不再维护auto_excerpt的功能，我使用了第三方的工具<a href="https://github.com/chekun/hexo-excerpt">hexo-excerpt</a>进行了自动的配置，目前看应该是按段落行数截取的。</p>
<h2 id="日后的日常维护操作">日后的日常维护操作</h2>
<p>Hexo-cli常用的一些命令，<a href="https://hexo.io/zh-cn/docs/commands">参见中文文档</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 发表一篇新文章的流程</span></span><br><span class="line">$ hexo new draft <span class="string">&quot;文章名&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用本地server运行查看，默认访问网址为：http://localhost:4000/</span></span><br><span class="line">$ hexo server --draft</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将草稿文章添加到post中</span></span><br><span class="line"><span class="comment"># 也可以直接将_drafts文件夹中的文件直接手动移动到_posts文件夹中</span></span><br><span class="line">$ hexo publish <span class="string">&quot;文章名&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成public静态文件</span></span><br><span class="line">$ hexo generate</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进行远程部署</span></span><br><span class="line">$ hexo deploy</span><br><span class="line"></span><br><span class="line"><span class="comment"># 特定情况下，需要进行清除操作</span></span><br><span class="line"><span class="comment"># 清除缓存文件 (db.json) 和已生成的静态文件 (public)</span></span><br><span class="line">$ hexo clean</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Apache</tag>
      </tags>
  </entry>
  <entry>
    <title>使用牛顿法解决开平方问题</title>
    <url>/posts/63507/</url>
    <content><![CDATA[<p>这个问题的起因是我在做leetcode上的一道题延伸出来的，原题目是<a href="https://leetcode-cn.com/problems/sqrtx/">Leetcode 69. Sqrtx</a>。不过这道题目还是做了很大的简化，它只让我们找出符合要求的整数解。在实际运算中，我们显然希望获得一个开平方的精确小数值，比如说像 <span class="math inline">\(\sqrt{2} = 1.414214, \sqrt{3} = 1.732051\)</span> 这个样子。这里就需要使用牛顿法来进行求解了。这也是目前计算机学科中进行开平方运算的标准方法。下面我就来详细说说对这一算法的分析。</p>
<h2 id="牛顿法的解题思路">牛顿法的解题思路</h2>
<p>牛顿法告诉我们：</p>
<p>假设方程<span class="math inline">\(f(x) = 0\)</span>在<span class="math inline">\(c\)</span>处有一个根，那么可以用以下这个迭代的式子： <span class="math display">\[
x_{n+1} = x_n - \frac{f(x_n)}{f&#39;(x_n)}
\]</span> 依次计算出<span class="math inline">\(x_1\)</span>，<span class="math inline">\(x_2\)</span>，<span class="math inline">\(x_3\)</span>......，如此数列将无限逼近于方程的根(<span class="math inline">\(c\)</span>)。</p>
<p>我们从几何意义上来理解牛顿法，会比较容易。根据点斜式，可以很轻松的写出在<span class="math inline">\((x_n, f(x_n))\)</span>处的切线方程为<span class="math inline">\(y = f&#39;(x_n) * (x - x_n) + f(x_n)\)</span>。递推式中的<span class="math inline">\(\frac{f(x_n)}{f&#39;(x_n)}\)</span>这一项，相当于是这个切线方程与<span class="math inline">\(x\)</span>轴相交后形成的直角三角形在<span class="math inline">\(x\)</span>轴上的距离。每次做这样的递推，就会越来越接近原函数<span class="math inline">\(f(x) = 0\)</span>的那个零点。</p>
<p>下面这张图很好的展示了这种数列逼近的效果:</p>
<p><img src="https://www.math24.net/wp-content/uploads/2019/04/calc1-newtons-method1b.svg" /></p>
<p>由此，我们就可以把牛顿法运用到开平方的运算中来了。对于求解<span class="math inline">\(\sqrt{a}\)</span>这个式子，相当于求解方程<span class="math inline">\(f(x) = x^2 - a = 0\)</span>。也就是函数<span class="math inline">\(f(x)\)</span>的零点。<span class="math inline">\(f(x)\)</span>的一阶导数可以写为<span class="math inline">\(f&#39;(x) = 2x\)</span>，这样，牛顿迭代式为： <span class="math display">\[
x_{n+1} = x_n - \frac{x_n^2 - a}{2x_n} = \frac{1}{2}(x_n + \frac{a}{x_n})
\]</span> 我们假设求解<span class="math inline">\(\sqrt{2}\)</span>，任意设置迭代的初值（非负数），比如为<span class="math inline">\(x_0 = 1\)</span>，带入上面的迭代式进行运算，可以得到： <span class="math display">\[
\begin{aligned}
&amp;x_0 = 1, \\
&amp;x_1 = \frac{1}{2} * (1 + \frac{2}{1}) = 1.5, \\
&amp;x_2 = \frac{1}{2} * (1.5 + \frac{2}{1.5}) = 1.41666, \\
&amp;x_3 = \frac{1}{2} * (1.41666 + \frac{2}{1.41666}) = 1.414216, \\
&amp;......
\end{aligned}
\]</span> 由此我们也可以写出相应的代码来快速的得到答案，下面是一个<a href="https://introcs.cs.princeton.edu/java/13flow/Sqrt.java.html">Princeton大学</a>写的一个Java语言的版本：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用牛顿法解决开平方问题</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> EPSILON = <span class="number">1.0e-15</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">double</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> t = a;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (Math.abs(t - a / t) &gt; EPSILON * t) &#123;</span><br><span class="line">            t = (t + a / t) / <span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> a = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">new</span> Solution().sqrt(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对于1e9+7的运算迭代结果如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">a = 1.000000007E9</span><br><span class="line">x[0] = 1000000007.00000000000000000000</span><br><span class="line">x[1] = 500000004.00000000000000000000</span><br><span class="line">x[2] = 250000003.00000000000000000000</span><br><span class="line">x[3] = 125000003.49999999000000000000</span><br><span class="line">x[4] = 62500005.74999991000000000000</span><br><span class="line">x[5] = 31250010.87499927400000000000</span><br><span class="line">x[6] = 15625021.43749418100000000000</span><br><span class="line">x[7] = 7812542.71870341100000000000</span><br><span class="line">x[8] = 3906335.35900220370000000000</span><br><span class="line">x[9] = 1953295.67670501510000000000</span><br><span class="line">x[10] = 976903.81598531710000000000</span><br><span class="line">x[11] = 488963.72911088780000000000</span><br><span class="line">x[12] = 245504.43529787744000000000</span><br><span class="line">x[13] = 124788.84074657578000000000</span><br><span class="line">x[14] = 66401.18893134680000000000</span><br><span class="line">x[15] = 40730.58017145583000000000</span><br><span class="line">x[16] = 32641.07897445094600000000</span><br><span class="line">x[17] = 31638.66067713355000000000</span><br><span class="line">x[18] = 31622.78069957933300000000</span><br><span class="line">x[19] = 31622.77671236376000000000</span><br><span class="line">x[20] = 31622.77671236351300000000</span><br><span class="line"></span><br><span class="line">Process finished with <span class="built_in">exit</span> code 0</span><br></pre></td></tr></table></figure>
<h2 id="牛顿法背后的数学原理">牛顿法背后的数学原理</h2>
<p>我们作为后人，当然可以直接使用400年前牛顿发明的这种算法而不假思索。但是，如果我们作为一个算法最初的设计者，就必须要想的更多一些，那就是：为什么这样做一定可以找到一个数的平方根呢？（从数学的角度来说，就是：满足上述递归条件的数列，是否一定收敛于函数<span class="math inline">\(f(x) = x^2 - a\)</span>的零点呢）只有先在数学上完成这样的证明，我们才有理由说这个算法是严谨有效的。下面我将给出两种对牛顿法正确性的数学证明。</p>
<p>第一种是英文版的维基百科<a href="https://en.wikipedia.org/wiki/Newton%27s_method">Newton's method</a>词条中给出的证明，我简单用我理解的中文在此复述如下：</p>
<p>根据<a href="https://en.wikipedia.org/wiki/Taylor%27s_theorem">泰勒定理</a>，任何函数<span class="math inline">\(f(x)\)</span>当它有连续的二阶导数时，那么靠近函数<span class="math inline">\(f(x)\)</span>零点（我们假设为<span class="math inline">\(\alpha\)</span>，<span class="math inline">\(\alpha = \sqrt{a}\)</span>）的点都可以写为泰勒展开式如下： <span class="math display">\[
f(\alpha) = f(x_n) + f&#39;(x_n)(\alpha - x_n) + R_1
\]</span> 在此，泰勒级数展开式的拉格朗日余项为： <span class="math display">\[
R1 = \frac{1}{2!}f&#39;&#39;(\xi_n)(\alpha - x_n)^2
\]</span> 这里的<span class="math inline">\(\xi_n\)</span>在<span class="math inline">\(x_n ～ \alpha\)</span>的范围内，因为<span class="math inline">\(\alpha\)</span>是函数的一个根，所以上面的泰勒展开式相当于: <span class="math display">\[
\begin{aligned}
&amp;0 = f(\alpha) = f(x_n) + f&#39;(x_n)(\alpha - x_n) + \frac{1}{2!}f&#39;&#39;(\xi_n)(\alpha - x_n)^2 \\
\Leftrightarrow \quad &amp;\frac{f(x_n)}{f&#39;(x_n)} + (\alpha - x_n) = \frac{-f&#39;&#39;(\xi_n)}{2f&#39;(x_n)}(\alpha - x_n)^2
\end{aligned}
\]</span> 由于我们定义了数列<span class="math inline">\(\lbrace x_n \rbrace\)</span>的递推式为<span class="math inline">\(x_{n+1} = x_n - \frac{f(x_n)}{f&#39;(x_n)}\)</span> ，因此上式可以写为： <span class="math display">\[
\begin{aligned}
\underbrace{\alpha - x_{n+1}}_{\epsilon_{n+1}}
 &amp;= \frac{-f&#39;&#39;(\xi_n)}{2f&#39;(x_n)}(\underbrace{\alpha - x_n}_{\epsilon_n})^2 \\
\Leftrightarrow \quad \epsilon_{n+1} &amp;= \frac{-f&#39;&#39;(\xi_n)}{2f&#39;(x_n)} \cdot \epsilon_n^2
\end{aligned}
\]</span> 根据数列极限的定义，我们定义<span class="math inline">\(\epsilon_n = \alpha - x_n\)</span>，对于上式两边取绝对值，有： <span class="math display">\[
\begin{aligned}
|\epsilon_{n+1}| &amp;= \frac{|f&#39;&#39;(\xi_n)|}{2|f&#39;(x_n)|} \cdot |\epsilon_n|^2 \\
\Leftrightarrow \quad \frac{|\epsilon_{n+1}|}{|\epsilon_n|} &amp;= \underbrace{\frac{|f&#39;&#39;(\xi_n)|}{2|f&#39;(x_n)|}}_{M} \cdot |\epsilon_n|
\end{aligned}
\]</span> 对于函数<span class="math inline">\(f(x) = x^2 - a\)</span>，我们可以得到函数的一阶导数为<span class="math inline">\(f&#39;(x) = 2x\)</span>，函数的二阶导数为<span class="math inline">\(f&#39;&#39;(x) = 2\)</span></p>
<p>此时，上式中的<span class="math inline">\(M\)</span>项可以写为： <span class="math display">\[
M = \frac{1}{2} \cdot \frac{|2|}{|2x_n|} = \frac{1}{2|x_n|}
\]</span> 由此，可以得到整个右式： <span class="math display">\[
\begin{split}
M \cdot |\epsilon_n| &amp;= \frac{1}{2|x_n|} \cdot |x_n - \alpha| \\
&amp;= \frac{1}{2} \cdot \Bigg| \frac{x_n - \alpha}{x_n} \Bigg| \\
&amp;= \frac{1}{2} \cdot \bigg| 1 - \frac{\alpha}{x_n} \bigg| 
\end{split}
\]</span> 对于任意的正数<span class="math inline">\(x_n\)</span>，<span class="math inline">\(\alpha\)</span>，能够得到整个右式<span class="math inline">\(M \cdot |\epsilon_n| &lt; 1\)</span>，因此数列一定收敛。</p>
<p>第二种证明是我和高中同学刘浩（不愧是考研的人，数学就是比我好...）讨论的方法，更加简单易懂一些:</p>
<p>需要用到一个简单的推论： <span class="math display">\[
\begin{aligned}
\forall a, b \in R^+, \quad (a + b)^2 &amp;\ge 4ab \\
\Rightarrow \ \frac{1}{4}(a + b)^2 &amp;\ge ab \\
\Rightarrow \ \frac{1}{2}(a + b) &amp;\ge \sqrt{ab}
\end{aligned}
\]</span></p>
<p>此时， <span class="math display">\[
\begin{aligned}
x_{n+1} &amp;= \frac{1}{2}(x_n + \frac{a}{x_n}) \\
&amp;\ge \sqrt{x_n \cdot \frac{a}{x_n}} = \sqrt{a}
\end{aligned}
\]</span> 也就是说，我们证明了对数列中的任意一项<span class="math inline">\(x_n\)</span>(除了初始值<span class="math inline">\(x_0\)</span>由用户规定外)都有<span class="math inline">\(x_n \ge \sqrt{a}\)</span>，因此我们得到以下的不等式恒成立： <span class="math display">\[
\begin{gather*}
\frac{a}{x_n} \le \frac{a}{\sqrt{a}} = \sqrt{a} \le x_n \\
x_{n+1} = \frac{1}{2}(x_n + \frac{a}{x_n}) \le \frac{1}{2}(x_n + x_n) = x_n
\end{gather*}
\]</span> 即我们证明了数列<span class="math inline">\(\lbrace x_n \rbrace\)</span>单调递减并且有下界<span class="math inline">\(\sqrt{a}\)</span>，根据单调有界必有极限的定理（<a href="https://en.wikipedia.org/wiki/Monotone_convergence_theorem">Monotone convergence theorem</a>），可以证明这一递推数列收敛于<span class="math inline">\(\sqrt{a}\)</span></p>
<p>令<span class="math inline">\(x_{n+1} = x_n = \sqrt{a}\)</span>带入检验，发现递推式成立： <span class="math display">\[
\begin{aligned}
&amp;左式 = x_{n+1} = \sqrt{a} \\
&amp;右式 = \frac{1}{2}(x_n + \frac{a}{x_n}) = \frac{1}{2}(\sqrt{a} + \frac{a}{\sqrt{a}}) = \sqrt{a}
\end{aligned}
\]</span></p>
<h2 id="牛顿法的算法复杂度">牛顿法的算法复杂度</h2>
<p>在第一种证明的时候，我们可以看到牛顿法的收敛速度是平方级别的：<span class="math inline">\(|\epsilon_{n+1}| \le M \cdot |\epsilon_n|^2\)</span>。因此它的算法复杂度可以这样来表示<span class="math inline">\(O(\log{n} \cdot F(n))\)</span>，这里的<span class="math inline">\(F(n)\)</span>是我们在计算迭代式中<span class="math inline">\(\frac{f(x)}{f&#39;(x)}\)</span>这一项时需要的n位精确度的开销。这里参见了维基百科中<a href="%5Bhttp://en.citizendium.org/wiki/Newton%27s_method#Computational_complexity%5D(http://en.citizendium.org/wiki/Newton&#39;s_method#Computational_complexity)">Newton's method</a>这一词条的内容。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>学习计算机科学的方法论</title>
    <url>/posts/327/</url>
    <content><![CDATA[<p>计算机科学（Computer Science，以下简称CS）包罗万象，博大精深。由于是一门操作性极强且又极为复杂的学科，因此对新手并不友好。我个人从大学四年的专业学习上，只能说是积累了一点经验，打下了一点基础。我就在此谈一谈个人对于学习计算机科学的方法论，为接下来自己的自学提高指明一个方向。</p>
<p>我把自我的学习简单分为以下几种形式，缺一不可。</p>
<h2 id="看书">看书</h2>
<p>我想把看书作为一个最重点的内容来谈。很多程序员觉得网络是必不可少的工具，因而过分的重视网络上的信息获取，反而轻视了书本阅读。我自己也在很长的一段时间内犯过这样的错误。事实上，书籍阅读的学习是十分体系化的，一本好书往往能帮助个人建立起整个知识体系结构，打通各个知识点之间的关联与互动，这些内容是自己通过零碎的网络信息获取所不能得到的。而且，网络上的资源参差不齐，许多说法互相矛盾，还要大部分都是抄袭、转载、浮于表面的东西。如果你愿意并且手边有质量高的书籍的话，你会发现很多几篇大段文章都说不清楚的概念，在书本上寥寥几句话就说明白了。</p>
<p>如何选择书籍是一门学问。我觉得就个人的经验来说，在决定阅读或购买一本技术书之前，在<code>豆瓣</code>上进行评分查看是个不错的选择。一般来说评分在<code>8.0</code>以上的都是用心写了的，有一定的可取之处，可以作为免费借阅的书籍选择。在<code>9.0</code>分之上的大部分情况下可以考虑直接购买，不会有太大的问题。另外，技术书籍是<strong>买新不买旧</strong>的，追求<code>3-5</code>年内的最新版本往往来说是最贴合当下的，没有过时的技术。我个人觉得外国人写书还是比中国人写书要好一些，但是外国书有个很大的问题就是翻译问题，这个直接影响到最终的阅读体验，所以一定要注意<code>豆瓣</code>下面关于书籍翻译质量的评论。图灵书的翻译质量是最高的，其次是异步图书、动物书、人物书也可以，华章和黑皮的机械工业书翻译质量参差不齐，需要仔细鉴别一下。<strong>在现阶段，自己不宜也不要去直接挑战英文版的书籍阅读，无谓的增加学习难度并且极有可能半途而废</strong>。</p>
<p>最后说一个个人目前新的想法：<strong>那就是高质量的书籍还是买回来看好</strong>，这里所说的，就是纯粹为了个人兴趣学习的目的，不是为了一时完成作业、查阅一个小知识点这种零碎的学习。虽然中国有话说<strong>书非借不能读</strong>，但是借书的话在阅读的过程中有太多限制，不能自由的划重点、做批注这样。技术书的阅读是非常枯燥的，如果不通过这些方式调动自己积极主动的思考，那极大可能是看不下去整本书的。最后，中国的国情是书籍都很便宜，哪怕是特别厚的技术书也不过100块左右。所以说，<strong>只要是好书，买回来并且认真看完了，就只赚不赔</strong>。</p>
<h2 id="动手实践">动手实践</h2>
<p>动手实践和理论学习对于CS学科是同等重要的。一个人要是十天半月不写代码，那么他的代码能力绝对是会下降的。一个完整的项目，或者一个优质的课程作业，需要从最初的环境配置做起，到整体设计、代码实现、调试和试错，最后进行部署或发布，牵涉到了方方面面的内容。<strong>很多之前看到过的似是而非、没有完全理解和掌握的知识点，都是在动手实践中才能加深理解的</strong>。要知道整个CS学科是一门立足实践的科学，所有的概念和算法都有与之对应的代码负责具体的实现。<strong>Talk is cheap. Show me the code！</strong></p>
<p>自己在动手实践上目前存在着非常大的不足之处，最近一两年来都没有什么大的、好的项目可以拿的出手。这是接下来一段时间内在看书学习之余需要着力提高的一个地方。</p>
<h2 id="网络资源">网络资源</h2>
<p>许多的程序员都是<strong>面向网络编程</strong>的，这一点我们在初级阶段是无法回避的问题。希望有朝一日自己可以闭门造车还能写出高质量的代码，那就真的是达到极高的水平了。网络资源十分丰富：从文章帖子、文档手册、视频教程再到Github代码仓库一应俱全。就文章而言，我觉得最权威、最可信的莫过于官方的开发文档，其次是<code>StackOverflow</code>、<code>SegmentFault</code>这样的高质量网站或<code>DigitalOcean Community</code>这种开源社区的文章，再其次是一些个人搭建的博客和<code>知乎</code>、<code>掘金</code>、<code>简书</code>这样的博客平台或<code>腾讯云</code>，<code>美团</code>这样的开发者团队文章，最后是<code>CSDN</code>以及各种其他不入流网站。</p>
<p><code>Coursera</code>上有很多课程很值得一学，这也是自己接下来要努力学习的一个方向。我想多说一句，就是做一件事情就要把它做到最好。一个人的水平有高低，反映到成果上就是有高下之分，但是态度是同样重要的。为了知识而学，而不是为了证书而学，课程作业是和教学视频同等重要的，需要认真对待，不到万不得已不可随意抄袭别人。</p>
<h2 id="源码阅读">源码阅读</h2>
<p>这是提高自己代码能力的又一条重要途径。目前实践的不多，暂时按下不表。但是，那些优秀的代码框架、轮子、库函数都是前任编程设计的智慧，都用代码的形式展示给自己了。一个只会调用而从来不去研究源码的程序员，就是只懂实现而不懂原理，他对编程的理解和掌握度就永远是低层次的。</p>
<h2 id="同行和同辈的交流">同行和同辈的交流</h2>
<p>这个是我在大学四年中一直没有做的很好的地方。我深感身边很多人太难沟通和交流，三观不合，因而人际关系处理得极为不好。但是，同辈的交流促进就CS学习来说是十分重要的。一个人是不能闭门造车的学习的，至少要对身边人的学习研究的方向有个大概的认识了解，对行业的发展有个了解。这就需要结识那些真正热爱技术，不断潜心钻研的人。但是，真的好难啊！不是说大学没有这样的人，而是说这样的人太难接触，更难以跟自己结交朋友：不是过于狂傲看不起人，就是沉默木讷不言。将来读研期间换个环境再着力吧。</p>
<p>身边人能给带来的益处是很多的：<strong>从直接的手把手教学、优秀工具的使用、项目的设计到个人看法和习惯的改变</strong>。虽然大学期间的诸多团队合作项目体验不好，但是我还是对这方面抱有期待。不应该因为有人投机取巧，就不相信有踏实肯干的人；不应该因为有人急功近利，就不相信有纯粹热爱的人；不应该因为有人狂傲不羁，就不相信有乐于分享的人。</p>
<h2 id="论文阅读">论文阅读</h2>
<p>目前对这方面涉及不多，所以暂时按下不表。我只记得谁说过一句话：一个行业内最新的成果、最新的发展趋势，肯定是看这个方向上的学术论文，如果说已经出了书籍了，那就已经过时了。将来走科研路线的话，这真的是要下大力气的地方。</p>
]]></content>
      <categories>
        <category>感悟</category>
      </categories>
      <tags>
        <tag>方法论</tag>
      </tags>
  </entry>
  <entry>
    <title>对接下来一段时间自我学习的路线思考</title>
    <url>/posts/14894/</url>
    <content><![CDATA[<p>入学EPFL也有一学期的时间了，自己也算是逐渐适应了国外的学习生活。说实话，对于在瑞士的CS学习，我是不太满意的。当然这也跟自己初来乍到没有确定好未来的路线规划有很大的关系。现在，至少这个问题已经逐步清晰起来了。下面我就想主要地回顾一下自己的心路历程，同时为接下来一段时间的自我学习指明道路。</p>
<h2 id="研究生之前历史的回顾">研究生之前历史的回顾</h2>
<p>首先，自己第一次进行系统的CS自学规划，是在2019年9月份的时候，直到现在我还记得当时正是在备考第二次的GRE考试，每天晚上在国软后面的废弃操场散步思考是我难得的休息时间。当时，就是在这样压力的环境下，我开始了对结束英语学习以后，腾出来的大量时间该做什么进行了思考。当时初步定的想法就是打实基础，提高技术，为春招实习做准备。于是在这样的思路指导下，我从11月份结束国外申请后，用了40天的时间第一次系统啃完了《算法》（第四版）连同Coursera上Princeton的Algorithm课程，完成了所有的作业，并且在12月份开始进行Leetcode刷题，这种高强度的练习一直进行到2020年的春节期间（1月底）</p>
<p>之后突如其来的疫情打乱了我原有的计划安排，再加上毕业设计的时间挤占，以及最重要的，个人在家学习的极低效率，导致原有的计划不得不无限期拖延。期间虽然也强行参加了一些面试，笔试，但是都是三心二意，没有成体系地复习准备过，可以说仅仅是又一次的刷经验而已（如果这样的情况下我都能过，那只能说明是公司门槛太低了）。面对不得不调整的形势，我随即利用半年在家的时间，开始了一次本科阶段重要课程的巩固性书籍阅读，《深入理解Java虚拟机》（第二版）、《MySQL技术内幕:InnoDB存储引擎》、《操作系统导论》（OSTEP）、《Java实战》（第二版），基本上是一个月一本书的阅读速度。这显然是比较慢的，但是却因此大大提高了我个人对于技术书籍阅读的自信心。我是有能力进行完整的技术书阅读的，而不再是像本科时期的很多课程一样，书只看一点点就停下不看了。</p>
<p>但是，这样的学习其实现在看来也是存在着问题的，最大的两个问题就是：第一，太慢，不得不说自己看书的速度实在是堪忧，有一段时间甚至就是在强迫自己看，“啃书”一词可以说是非常形象的了。自己在看书的时候也会有意放慢速度，尝试去查找，弄懂一些关联性的概念等等，总之就是读得太仔细，太认真了。这当然从静下心来研究的角度来说不是什么坏事，但是对于个人的技术成长进步来说，依然是显得太慢了。正确的、符合人类记忆的做法是多次的重复阅读，而非一次性的精读。第二，就是没有配套的练习/编程机制，不知道具体的代码实现，导致了很多东西学了又忘，以至于半年后的今天很多概念又变得模糊了起来。这两点问题，是以后自己读书应该着力避免的。</p>
<p>之后的8月份，有鉴于自己动手能力实在是太差，没有任何能打的项目写在简历上拿的出手，因此我开始了Coursera上面Programming Language系列的学习，这个分成了两部分，8月份的前25天完成了一半的课程；后面的一半直到今年春节之前（1月20日考完试花了15天时间完成）。在这个过程中，使用VSCode编程极大提高了我个人对于任何一门新语言的自信心，现在即便是随便给我一个从未用过的新语言，我也有信心很快地去掌握并使用它。但是，我自己的初衷并没有很好地达到，也就是说，代码量依然不够看（每个作业也就是100-200行的代码量，不管怎么说这只是UW的本科课程而已啊）</p>
<h2 id="研究生半年的体验">研究生半年的体验</h2>
<p>首先，我想记录一下自己为什么选择来洛桑，而不是去美国读书。这其中固然有很多额外因素的考虑（比如说金钱花销，疫情）等等，但是最主要的考虑是这样的：我觉得绝大多数的美国master项目，其时间长度（一般是1年半 - 2年）就是为了找工作去的，换句话说，我人一旦到了美国，就要考虑找工作的事情。这样短平快的思路是让我很不舒服的。由于本科时期长期的功利主义、结果主义的思维导向，造成了我对于技术方面没有踏实深入的、静下心来的钻研；而是怎么快地掌握怎么来，浮于表面，不求甚解，根本经不起任何的考验。所以我正是看中了来瑞士可以有比较充分的转圜时间（不管是决定找工作也好，还是决定走科研路线也好，都有静下来的充分的自我时间），才选择来到这里的。</p>
<p>其实刚开始在EPFL选课的时候，心里还是挺激动的，对于国外的课程质量也抱有很大的期望。也曾经一度萌生过读博的想法，因此在选课上，还是选择了一些热门的（比如Machine Learning，Natural Language Processing这些），但是我很快就发现自己挖了一个大坑，而且大到超过了自己的能力范围。一直以来，数学都不是我的强项，但是要往AI方向深入地学习，数学必不可少，甚至比编程能力重要得多。如果要入坑的话，那我估计很多本科的课程都需要仔细钻研了（比如高等数学，概率论，线性代数）。经过我再三的思考，我还是决定放弃这个领域（虽然它确实很诱人，而且相关的资源也有很多），专注于对未来找工作有帮助的System方向。</p>
<p>除了让我痛苦的AI方向，EPFL的课程也可谓是一言难尽，就是确实比武汉大学的质量要高一些，考试的难度也大一些，但是依然是有很多概念性的东西，不求甚解。比如说TCP/IP虽然对于很多协议（比如BGP）的讲述比本科的计网课程详尽了很多，也有一些配套的练习；或者是Distributed Algorithm对于各种Broadcast的概念讲解。但是我依然学完了之后没有很大的提高，既不知道这些的本质（如何用C语言实现TCP/IP协议？），也不知道这些概念对应的应用到底为何（DDIA书上貌似有一章详细地解释了Broadcast算法）。感觉还是停留在一种学校象牙塔里的学习。这时候就不得不说美国的学校了，必须要承认名校就是名校，如果我配套完成了CMU的15-441 Project，或者是MIT的6.824 Project，或许就能对Network，DA有更深的理解了。这当然只能是自己课余的努力，而非EPFL课程本身所能带给自己的了。</p>
<p>我自己目前对于本质的问题看得很重，如果学习依然是停留在概念的记忆上，那我觉得跟本科也差不了太多了。不管是对于AI的算法也好（从数学上我就能证明这个算法它就是好的，就是对的），还是对于System的计算机网络，操作系统，数据库...了解它本质的运行情况（一行命令/代码下去到底发生了什么），做到如同机器一样的思考，是我目前特别希望自己能拥有的能力。因此，在之后的学习中，我都希望自己能够不在意成绩的高低，而是着重在意这样的本质思考能力。</p>
<p>第一学期由于各种生活上的原因，非学习的时间很多，整个一学期在疫情下战战兢兢，不能很好地静下心来做自己的正事。因此除了正课之外，可以说没有任何其余的学习投入，有时候甚至一天工作1-2小时就是胜利了，这是非常不好的（也由此中断了连续几个月的自学提高）。之后的学期再也不能延续同样的状态了，至少，每天要能工作5-6小时吧，再留下2-3小时的休闲娱乐。</p>
<h2 id="接下来的自我学习">接下来的自我学习</h2>
<p>第一学期最大的耻辱，不是在于最后的考试成绩上（说实话，我现在已经完全摆脱了长期以来的成绩束缚，身心高度自由），而是自己因为惧怕C/C++语言，因而直接撤掉了Concurrent Algorithm这门课程。对于C/C++的恐惧心理是我必须要克服的。因为不克服这种恐惧，我自己所希望的，能够了解本质的学习就不能进行下去。不管是Operating System的Kernel编程，还是DataBase的B+树数据存储，亦或是TCP/IP协议栈的实现，甚至是Java虚拟机的功能实现，都离不开C/C++语言。如果害怕这门语言，那了解底层原理，读懂底层代码就无从谈起。自己所谓的本质主义思考也就是不可能的。</p>
<p>对于未来，我计划的CS自我学习提高放在以下两个方面：</p>
<p>第一，看书。这次由于环境所限，要挑战一下第一次看全英文的书籍了。我希望能在上课之余先完成《C++ Primer》的阅读，每天50页，共需一个月的时间（一定一定要注意阅读速度，速度就是一切）。之后，再说Effective系列的书籍阅读。</p>
<p>第二，项目。能够把之前的CA Project完成是最好的，如果没有时间，那着重做好Compiler的课程作业也行。此外，还有自己从bilibili上看到的别人推荐的一些开源项目，也可以拿来阅读，作为自己代码风格的提高。</p>
<p>至于说额外的课程学习（CMU/MIT/Coursera上面的），估计要放在寒暑假期间了，毕竟自己也是有正课压力的呀，而且如果说遇到了EPFL的好课程，也是应该深入紧跟着学习的，不能完全偏废。平时如果真的还有时间和干劲的话，再考虑吧。</p>
]]></content>
      <categories>
        <category>感悟</category>
      </categories>
  </entry>
  <entry>
    <title>详解单例模式</title>
    <url>/posts/24828/</url>
    <content><![CDATA[<p>最近由于课程作业的缘故，使用Scala语言的次数较多。在Scala中，类型还是挺丰富的，其中有一种类型称为<code>Obejct</code>，可以说对应着Java中的单例模式，今天正好来详细说一下自己一直没有搞清楚的这个东西，同时也是面试中经常出现的一个知识点。</p>
<p>单例模式是一种比较特殊的设计模式（Design Pattern），在Java中，它表示一个Class只有一个实例化的Object。单例模式分为两种，一种叫饿汉模式（Object的new操作发生在Class创建时）；一种叫懒汉模式（Object的new操作发生在getInstance时）。这两种的区别就在于单例模式实例化Object的早晚。</p>
<p>其中，饿汉模式是一种标准的写法，这也是《Effective Java》一书中推荐的，其具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 这里的static member是public的，外部可以直接访问</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// initialize object</span></span><br><span class="line">    ....</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// other methods for Singleton instance</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ....</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这第一种写法是最基础的，在之后的代码中如果想使用单例，就直接调用<code>Singleton.INSTANCE</code>即可；另外还有一种写法，使用Static Factory Method，使得代码更加灵活。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// constructor, initialize object</span></span><br><span class="line">    ....</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> INSTANCE</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// other methods for Singleton instance</span></span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不管是是哪一种写法，都是属于饿汉模式，即在Singleton Class创建的时候就完成Object的new操作。这其中有两点最为关键：</p>
<p>第一点是声明构造函数（Constructor）为<code>private</code>，防止在其他Class的代码中new出新的Singleton Object；</p>
<p>第二点是提供一个<code>public static</code>的member/function或直接，或间接地让外部用户获得这个单例。</p>
<p>另外一种设计思路就是懒汉模式，它通常与多线程问题一起考察（含锁的双检查），主要是为了面试能够多引出一些知识点来，我个人认为实际的代码中一般不会用到这种，不过我们还是可以梳理一下面试思考问题的思路。</p>
<p>首先是最基础的版本：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// constructor, initialize object</span></span><br><span class="line">    ....</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">      instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// other methods for Singleton instance</span></span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它的问题在于多线程，当Thread1，Thread2同时检查到<code>if (instance == null)</code>时，此时都进入<code>if</code>语句块，假设此时Thread1先获得了CPU的控制权，那么它创建（new）了一个Singleton对象，然后返回；紧接着Thread2获得CPU，也会创建一个Singleton对象，那么相当于此时内存堆中拥有两个不同的Singleton Object，违反了单例模式。</p>
<p>解决的方案有两种，第一种是最简单的，直接对<code>getInstance</code>函数加锁（<code>synchronized</code>），不过这样是一种简单粗暴的互斥访问，会造成并发量的下降（关于<code>synchronized</code>底层实现的本质和具体的性能表现我尚未有特别详细的研究）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二种方法就稍微复杂些，那就是含锁的双检查：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">      <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里为什么是<code>if (instance == null)</code>检查两次呢？第一次的检查非常好理解（看看是不是已经创建了instance，有的话就直接返回，节省进入<code>synchronized</code>的开销），第二次的检查是为了避免创建两个不同的单例对象，违反单例模式的原则。具体来说是这样的：</p>
<p>如果Thread1，Thread2同时处于<code>synchronized(Singleton.class)</code>这一临界区间（Critical Section）等待获取锁。此时，如果Thread1先进入，那么Thread2就会因获得不到锁而进入<code>BLOCKED</code>状态，再也无法和<code>RUNNABLE</code>状态的Thread1竞争CPU的时间片，它只能被动等待synchronized锁的释放并获得锁，然后再进入<code>RUNNABLE</code>状态。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Thread1</th>
<th style="text-align: center;">Thread2</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">获取synchronized锁</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">再次判断instance为空</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;">创建并完成instance的初始化</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">释放synchronized锁</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;">返回已初始化的instance</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">获取synchronized锁</td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;">判断instance不为空</td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">（如果没有第二次检查，那么就会再创建一个Singleton对象）</td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;">返回已初始化的instance</td>
</tr>
</tbody>
</table>
<p>含锁的双检查模式已经是足够好了，但是还不是最好的。这是因为实例化对象的代码<code>instance = new Singleton();</code>实际上包含了3个操作：</p>
<ol type="1">
<li>分配对象的内存空间</li>
<li>初始化对象</li>
<li>将<code>instance</code>引用指向刚分配的内存空间</li>
</ol>
<p>在Java中编译器存在指令的重排序，所以以上的3个操作不一定会依次按步骤进行，第2步和第3步有可能会进行重排序，此时这一行代码的执行操作是：</p>
<ol type="1">
<li>分配对象的内存空间</li>
<li>将<code>instance</code>引用指向刚分配的内存空间</li>
<li>初始化对象</li>
</ol>
<p>此时对于Thread1，Thread2来说，就存在以下的一种多线程执行顺序：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Thread1</th>
<th style="text-align: center;">Thread2</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">判断instance为空</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">获取synchronized锁</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;">再次判断instance为空</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">分配instance的内存空间</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;">将instance引用指向刚分配的内存空间</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">判断instance不为空</td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;">返回未初始化的instance</td>
</tr>
<tr class="even">
<td style="text-align: center;">初始化instance</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;">释放syncrhonized锁</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">返回已初始化的instance</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<p>注意，这里尽管Thread1运行在synchronized代码块中，但是依然存在CPU时间片的线程切换，这是因为在Java线程模型中，将OS中的Ready（就绪），Running（运行）都认为是<code>RUNNABLE</code>的状态。也就是说，所有处于<code>RUNNABLE</code>状态的线程，都有争夺CPU时间片的资格。Thread2并没有因为执行到<code>synchronized</code>代码块前没有获得锁而进入<code>BLOCKED</code>状态，所以就可以和Thread1争夺CPU控制权。</p>
<p>因此，我们说<code>synchronized</code>关键字能保证在它划定的临界区间（Critical Section）中最多只有一个线程能够运行；但是它不能保证当线程在临界区间上运行时，不会被其他<code>RUNNABLE</code>状态的线程切换。</p>
<p>此时，Thread2就会提前返回一个（内存堆中）没有完成初始化的Singleton instance对象，<strong>虽然说没有在内存堆中生成两个以上的对象，违反单例原则，但是没有完成初始化的对象会造成后续操作的不可预见性</strong>。</p>
<p>正确的<strong>避免指令重排序的方法就是对<code>instance</code>使用<code>volatile</code>关键字</strong>，所以最后的正确版本是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// constructor, initialize object</span></span><br><span class="line">    ....</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">          instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// other methods for Singleton instance</span></span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>详解浮点数</title>
    <url>/posts/16352/</url>
    <content><![CDATA[<p>这篇文章跟我的上一篇<strong>"使用牛顿法解决开平方问题"</strong>直接相关，当时在书写牛顿法的迭代代码时，需要判断循环终止的条件。Princeton大学的版本使用的是<code>while (Math.abs(t - a / t) &gt; EPSILON * t)</code>这样的语句，初看貌不惊人，实际上思考起来却大有玩味。不要看就这简简单单的几行程序，我相信会有很多人在第一次写的时候，会像我一样写成<code>while (Math.abs(a - t * t) &gt; EPSILON)</code>或者是比较当前值和下一次运算迭代值的<code>while (Math.abs(a / t - t) / 2.0 &gt; EPSILON)</code>这个样子。实际上，后两种的写法都是有问题的。那么这里面的学问是什么呢？这就需要我们对于计算机的浮点数运算有深入的理解才能进行回答。</p>
<p>我们知道，数学中的小数是无穷无尽的，但是计算机只能用有限的位数（单精度浮点数32位，双精度浮点数64位）进行表达。这就意味着，一定有一些数是计算机无法准确表达的。然而不幸的是，我们无论是在机器学习，计算机图形学，数据分析等等领域，用到浮点数的计算又相当之广泛，这就给计算机的浮点数表示形式带来了很大的挑战。如果不清楚浮点数的本质原理，就会很容易在程序编写中造成意想不到的问题。战战兢兢，如履薄冰，这是我们在使用浮点数时应有的谨慎态度。</p>
<h2 id="浮点数的表达形式和精度">浮点数的表达形式和精度</h2>
<p>浮点数的表达形式遵循<strong>IEEE 754</strong>中的规范，即<strong>使用以2为基数的有限小数位的科学记数法（Scientific Notation）来表示和存储</strong>。以32位浮点数为例，表示形式为：</p>
<p><img src="https://pic.stackoverflow.wiki/uploadImages/2408/8207/1929/f1e0/9977/b0ca/17c7/19f/2020/05/29/10/48/7de7e9b3-768f-4881-aba1-3fde1eff14dc.svg" /></p>
<ul>
<li>1位：符号位（sign），0表示正数，1表示负数</li>
<li>8位：指数位（exponent），范围0-255</li>
<li>23位：小数位（fraction），通常表示1.xxx小数点后面的有效数字，即<span class="math inline">\(0.f_1f_2f_3...f_{23}\)</span>，也有例外</li>
</ul>
<p>对于浮点数的数值表示，可以用以下这个公式进行描述： <span class="math display">\[
V = (-1)^S \times M \times 2^E
\]</span></p>
<p>根据exponent的不同，我们将浮点数分为三种类型：</p>
<ol type="1">
<li><p>规格化的值</p>
<p>当<strong>Exponent不全为0且不全为1</strong>时，这时是浮点数的一般情况，此时<span class="math inline">\(M = 1 + fraction = 1.f_1f_2f_3...f_{23}\)</span>，<span class="math inline">\(E = exponent - Bias\)</span>，这里<span class="math inline">\(Bias = 2^{8 - 1} - 1 = 127\)</span>。规格化值在<span class="math inline">\([1 \times 2^{-126}, (2-2^{-23}) \times 2^{127}]\)</span>区间分布，<strong>越远离数轴0值分布越稀疏，越接近数轴0值分布越密集</strong>（只考虑非负数，负浮点数与正浮点数以原点0在数轴上对称分布）。</p></li>
<li><p>非规格化的值</p>
<p>当<strong>Exponent全为0</strong>时，此时属于非规格化的浮点数，<span class="math inline">\(M = fraction = 0.f_1f_2f_3...f_{23}\)</span>，<span class="math inline">\(E = 1 - Bias = -126\)</span>，采用这样的定义方式是为了<strong>均匀的表示非常接近于0的数</strong>，保证在<span class="math inline">\([0, 2^{-127})\)</span>区间内也有浮点数的分布（全按规格化值来的话这一区间是没有浮点数数值的），所有的非规格化值在<span class="math inline">\([0, (2 - 2^{-23}) \times 2^{-126}]\)</span>区间上均匀分布（只考虑非负数）。</p></li>
<li><p>特殊值</p>
<p>当<strong>Exponent全为1</strong>时，此时分为两种情况：若fraction部分<strong>不全为0</strong>，则表示特殊值“NaN”（Not a Number）；若fraction部分<strong>全为0</strong>，则表示正无穷（<span class="math inline">\(+\infty\)</span>）或负无穷（<span class="math inline">\(-\infty\)</span>）。</p></li>
</ol>
<table>
<colgroup>
<col style="width: 10%" />
<col style="width: 2%" />
<col style="width: 7%" />
<col style="width: 2%" />
<col style="width: 10%" />
<col style="width: 20%" />
<col style="width: 44%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Sign</th>
<th style="text-align: left;">Actual Exp</th>
<th style="text-align: right;">Exp</th>
<th style="text-align: left;">Exponent field</th>
<th style="text-align: left;">Fraction field</th>
<th style="text-align: left;">Value</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">零</td>
<td style="text-align: left;">0</td>
<td style="text-align: left;">-126</td>
<td style="text-align: right;">0</td>
<td style="text-align: left;">0000 0000</td>
<td style="text-align: left;">000 0000 0000 0000 0000 0000</td>
<td style="text-align: left;">0.0</td>
</tr>
<tr class="even">
<td style="text-align: left;">负零</td>
<td style="text-align: left;">1</td>
<td style="text-align: left;">-126</td>
<td style="text-align: right;">0</td>
<td style="text-align: left;">0000 0000</td>
<td style="text-align: left;">000 0000 0000 0000 0000 0000</td>
<td style="text-align: left;">-0.0</td>
</tr>
<tr class="odd">
<td style="text-align: left;">一</td>
<td style="text-align: left;">0</td>
<td style="text-align: left;">0</td>
<td style="text-align: right;">127</td>
<td style="text-align: left;">0111 1111</td>
<td style="text-align: left;">000 0000 0000 0000 0000 0000</td>
<td style="text-align: left;">1.0</td>
</tr>
<tr class="even">
<td style="text-align: left;">负一</td>
<td style="text-align: left;">1</td>
<td style="text-align: left;">0</td>
<td style="text-align: right;">127</td>
<td style="text-align: left;">0111 1111</td>
<td style="text-align: left;">000 0000 0000 0000 0000 0000</td>
<td style="text-align: left;">-1.0</td>
</tr>
<tr class="odd">
<td style="text-align: left;">最小非规格化数</td>
<td style="text-align: left;">*</td>
<td style="text-align: left;">-126</td>
<td style="text-align: right;">0</td>
<td style="text-align: left;">0000 0000</td>
<td style="text-align: left;">000 0000 0000 0000 0000 0001</td>
<td style="text-align: left;"><span class="math inline">\(\pm 2^{-149} \approx \pm 1.4 \times 10^{-45}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">中间非规格化数</td>
<td style="text-align: left;">*</td>
<td style="text-align: left;">-126</td>
<td style="text-align: right;">0</td>
<td style="text-align: left;">0000 0000</td>
<td style="text-align: left;">100 0000 0000 0000 0000 0000</td>
<td style="text-align: left;"><span class="math inline">\(\pm 2^{-127} \approx \pm 5.88 \times 10^{-39}\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">最大非规格化数</td>
<td style="text-align: left;">*</td>
<td style="text-align: left;">-126</td>
<td style="text-align: right;">0</td>
<td style="text-align: left;">0000 0000</td>
<td style="text-align: left;">111 1111 1111 1111 1111 1111</td>
<td style="text-align: left;"><span class="math inline">\(\pm (1 - 2^{-23}) \times 2^{-126} \approx \pm 1.18 \times 10^{-38}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">最小规格化数</td>
<td style="text-align: left;">*</td>
<td style="text-align: left;">-126</td>
<td style="text-align: right;">1</td>
<td style="text-align: left;">0000 0001</td>
<td style="text-align: left;">000 0000 0000 0000 0000 0000</td>
<td style="text-align: left;"><span class="math inline">\(\pm 2^{-126} \approx \pm 1.18 \times 10^{-38}\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">最大规格化数</td>
<td style="text-align: left;">*</td>
<td style="text-align: left;">127</td>
<td style="text-align: right;">254</td>
<td style="text-align: left;">1111 1110</td>
<td style="text-align: left;">111 1111 1111 1111 1111 1111</td>
<td style="text-align: left;"><span class="math inline">\(\pm (2 - 2^{-23}) \times 2^{127} \approx \pm 3.4 \times 10^{38}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">正无穷</td>
<td style="text-align: left;">0</td>
<td style="text-align: left;">128</td>
<td style="text-align: right;">255</td>
<td style="text-align: left;">1111 1111</td>
<td style="text-align: left;">000 0000 0000 0000 0000 0000</td>
<td style="text-align: left;"><span class="math inline">\(+ \infty\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">负无穷</td>
<td style="text-align: left;">1</td>
<td style="text-align: left;">128</td>
<td style="text-align: right;">255</td>
<td style="text-align: left;">1111 1111</td>
<td style="text-align: left;">000 0000 0000 0000 0000 0000</td>
<td style="text-align: left;"><span class="math inline">\(- \infty\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">不是一个数</td>
<td style="text-align: left;">*</td>
<td style="text-align: left;">128</td>
<td style="text-align: right;">255</td>
<td style="text-align: left;">1111 1111</td>
<td style="text-align: left;">non zero</td>
<td style="text-align: left;">NaN</td>
</tr>
</tbody>
</table>
<p>64位的浮点数和32位的差不多，表示形式为：</p>
<p><img src="https://pic.stackoverflow.wiki/uploadImages/2408/8207/1929/f1e0/9977/b0ca/17c7/19f/2020/05/29/10/48/e02e0aa7-e5f1-4a60-8ffa-b1a19d9b0b70.svg" /></p>
<ul>
<li>1位：符号位（sign）</li>
<li>11位：指数位（exponent）</li>
<li>52位：小数位（fraction）</li>
</ul>
<p>类比32位的浮点数，可以知道<span class="math inline">\(Bias = 2^{11 - 1} - 1 = 1023\)</span>，64位浮点数的表示范围是：</p>
<p>非规格化浮点数<span class="math inline">\([0, (2 - 2^{-52}) \times 2^{-1022}]\)</span>(十进制表示约为<span class="math inline">\([0.0, 2.2 \times 10^{-308}]\)</span>)，</p>
<p>规格化浮点数<span class="math inline">\([1 \times 2^{-1022}, (2 - 2^{-52}) \times 2^{1023}]\)</span>(十进制表示约为<span class="math inline">\([2.2 \times 10^{-308}, 1.8 \times 10^{308}]\)</span>)</p>
<p>以下的图表描述了单精度浮点数（32位）和双精度浮点数（64位）二进制和对应的近似十进制转化：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gfnk3uuqp9j31d60d2wuf.jpg" /></p>
<h2 id="浮点数的运算和舍入">浮点数的运算和舍入</h2>
<p>不管是使用32位还是64位，都是使用有限的位数来表达数学中的小数，这就意味着一定有一些小数是无法准确使用计算机浮点数进行表达的。最典型的例子例如：<strong>使用浮点数表示0.7</strong></p>
<p>根据计算可以得知，十进制的0.7转化为二进制的表示是：0.1011(0011)* = <span class="math inline">\(1.011(0011) \times 2^{-1}\)</span>，因此转化为32位浮点数是Sign = 0, Exp = 126, frac = 011(0011)*，32位浮点数写为: 0011 1111 0011 0011 0011 0011 0011 0011，使用十六进制简写表示为：0x3f333333. 此时这个32位浮点数表示的实际值，实际上是: 0.699999988079071044921875</p>
<p>除了0.7之外，还有一些数是无法用浮点数准确表示的，<strong>比如以0.1为代表的所有以10为基数的负指数幂（1e-1, 1e-15, 3e-5这样的十进制科学计数。这个背后的问题是因为二进制无法在有限位准确表示1/5，就像我们说十进制中无法在有限位准确表示1/3一样）</strong>，这也就是为什么在涉及要求精确的金融数据计算时，不能使用IEEE 754浮点数的缘故，一般来说，推荐使用BigDecimal, int, long等类型进行金融计算。</p>
<p>以上在将十进制的0.7转化为二进制数时，已经使用到了浮点数的舍入（也就是保留二进制小数点右边前23位）：浮点数的舍入规则分为向偶数舍入、向零舍入、向上舍入、向下舍入四种情况，一般默认采用向偶数舍入(round-to-even, 也被成为向最接近的值舍入round-to-nearest)。例如：</p>
<p>当我们希望保留二进制小数点右边前2位时，我们会将<span class="math inline">\(10.00011_2(2\frac{3}{32})\)</span>向下舍入为<span class="math inline">\(10.00_2(2)\)</span>，<span class="math inline">\(10.0110_2(2\frac{3}{16})\)</span>向下舍入为<span class="math inline">\(10.01_2(2\frac{1}{4})\)</span>，这些值不是正中间值，因此直接进行舍入。我们将<span class="math inline">\(10.11100_2(2\frac{7}{8})\)</span>向上舍入为<span class="math inline">\(11.00_2(3)\)</span>，而将<span class="math inline">\(10.10100_2(2\frac{5}{8})\)</span>向下舍入为<span class="math inline">\(10.10_2(2\frac{1}{2})\)</span>，这些值都是两个可能值的中间值，此时根据向偶数舍入原则（使最低有效位为零）来操作。</p>
<p>在浮点数进行运算的过程中，同样涉及到了舍入，而且可能会产生意想不到的效果。例如：</p>
<p>使用32位浮点数计算表达式<span class="math inline">\((3.14 + 1e10) - 1e10\)</span>求值得到0.0，因为舍入，这里的3.14会丢失；相反，计算表达式<span class="math inline">\(3.14 + (1e10 - 1e10)\)</span>则会得到值3.14。这里，</p>
<p>1e10用二进制表示为：0101 0000 0001 0101 0000 0010 1111 1001(0x501502f9) = 10'000'000'000</p>
<p>比1e10小的上一个数：0101 0000 0001 0101 0000 0010 1111 1000(0x501502f8) = 9'999'998'976</p>
<p>比1e10大的下一个数：0101 0000 0001 0101 0000 0010 1111 1010(0x501502fa) = 10'000'001'024</p>
<p>可以看到，<strong>在32位浮点数中，1e10和上一个浮点数，以及下一个浮点数的距离之差高达1024！</strong>因此我们也就可以理解，当1e10先与3.14进行加法运算后，所得到的float值肯定是向下舍入为1e10，然后再与1e10相减变为0.0，在这一过程中，3.14就被舍入掉了。</p>
<p>（相比较而言，在64位浮点数表示下，1e10为：0x4202A05F20000000 = 10'000'000'000， 它的上一个数是：0x4202A05F1FFFFFFF = 9'999'999'999.999'998'092'651'367'187'5，下一个数是：0x4202A05F20000001 = 10'000'000'000.000'001'907'348'632'812'5，距离之差已经非常小了！）</p>
<p>由此，我们也就可以明白，32位浮点数采用23位fraction和64位浮点数采用52位fraction的精度差距在那里了：</p>
<p><strong>对于32位float，可以准确地表示<span class="math inline">\([-2^{24}, 2^{24}]\)</span>之间（相当于十进制数<span class="math inline">\([-16777216, 16777216]\)</span>）的任何整数，对于再往数轴两侧延伸的整数，则只能挑有限的进行表示（比如1e10可以准确表示，但是1e10 + 1就不能表示）</strong></p>
<p><strong>对于64位double，可以准确地表示<span class="math inline">\([-2^{53}, 2^{53}]\)</span>之间的任何整数，对于再往数轴两侧延伸的整数，则只能挑有限的进行表示。</strong></p>
<h2 id="非规格化浮点数">非规格化浮点数</h2>
<p>前面以及说过，当exponent部分取最小值0时，则目前的浮点数就是非规格化的（Denormal number）。非规格化数表示那些非常接近0的数，它是为了更好的处理算术下溢（underflow）而引入的。算术下溢是说浮点数计算的结果小于当前浮点数类型能表示的正常浮点数的最小值（最小非规格化数），此时即发生下溢。在没有非规格化浮点数的老式设计中，发生下溢的数会被直接刷新成0，而使用非规格化浮点数则可以使用一个最接近真实值的非规格化浮点数来表示运算结果，减少一定的精度损失。</p>
<p>非规格化浮点数在靠近0的地方均匀分布，这点与规格化浮点数越向数轴两侧延伸则两个相邻值距离越大的特点不同。</p>
<p>一般来说，不推荐在程序中使用非规格化的浮点数进行加、减、乘、除的运算。这是因为计算机硬件的缘故，会造成对非规格化浮点数的计算不能由处理器直接进行，而是需要进行陷入和特殊指令处理。一般来说，计算机对于非规格化浮点数的计算速度会比规格化浮点数慢10-100倍左右。</p>
<h2 id="浮点数的比较">浮点数的比较</h2>
<p>在谈及浮点数的比较之前，我们首先引入一个概念，叫做ULP（unit in the last place）。从浮点数分布来说，它描述的是任意一个给定的浮点数与比它fraction大1的下一个浮点数的距离值。正如上文所说，在32位float中，1e10的ULP就是1024.0。在Java中，可以使用Math.ulp()查看当前浮点数的ULP值。</p>
<p>浮点数的分布特点，可以这样来表述：在两个相邻的2的指数幂之间（比如<span class="math inline">\([2.0, 4.0]\)</span>之间，或是<span class="math inline">\([2^{-126}, 2^{-125}]\)</span>之间）的所有浮点数，它们的ULP相同；越向数轴两侧延伸，则ULP以2的倍数增长。唯一的例外是0和非规格化数，这些数相邻之间的距离都是相等的，以32位浮点数为例，ULP = <span class="math inline">\(2 ^ {-149}\)</span>(也就是最小非规格化的浮点数值)</p>
<p>有1个非常特殊的ULP值，那就是1.0时的ULP。在C语言的&lt;float.h&gt;中，这一特殊值被定义为<code>FLT_EPSILON</code>和<code>DBL_EPSILON</code>，即最小的浮点数值使得<code>1.0 + x != 1.0</code>：</p>
<p>在32位float中，这个值是<span class="math inline">\(2^{-23}\)</span>，也即是1.1920928955078125E-7</p>
<p>在64位double中，这个值是<span class="math inline">\(2^{-52}\)</span>，也即是2.22044604925031308084726333618E-16</p>
<p>为什么说这个值很特殊呢？这是因为在接下来要介绍的浮点数比较方法中，采用相对距离比较时<code>EPSILON</code>的取值一般默认就是这个值。另外，<strong>这个值与最小规格化浮点数的乘积刚好是最小非规格化浮点数，这意味着在两个规格化浮点数的比较过程中，判断条件右侧的表达式不会出现舍入为0.0的情况。</strong></p>
<p>比较两个浮点数a, b是否相近主要分为3种方法：</p>
<ul>
<li><p>绝对值比较（absolute difference），也就是我们说的abs(a - b)。这种方法问题很大，正如上文讨论ULP时提到的，使用<code>Math.abs(a - b) &lt;= EPSILON</code>进行比较时，若a，b的浮点数很大，则ULP很大，此时一个很小的<code>EPSILON</code>值无法准确的衡量两个数是否接近，甚至只有a，b相等的情况才会满足不等式条件。这也就解释了为什么引言中提到的两种绝对值比较的方法，都是错误的。除非我们可以保证<code>if (Math.abs(a - b) &lt;= EPSILON)</code>中的<code>EPSILON</code>能够大于1ULP，允许相近值的存在，否则原式就等价于<code>if (Math.abs(a - b) == 0.0)</code></p></li>
<li><p>相对距离比较（relative distance），这个是目前主流的比较两个数是否接近的方法，它比较的是一个比例，当两个浮点数之间的差值所占比例很小时，就认为两个浮点数是相近的。（这里分母取两浮点数中较大的、较小的、中间值都是可以的，以下仅以较大值为例）<code>Math.abs(a - b) / Math.max(a, b) &lt;= EPSILON</code>一般写作<code>if (Math.abs(a - b) &lt;= Math.max(a, b) * EPSILON)</code>我个人感觉这是因为由于浮点数本质是科学记数法，所以乘法的运算会比除法更快一些？这里<code>EPSILON</code>取值就有学问了，当取1.0时的ULP特殊值时，不等式的成立等同于要么两浮点数相等，要么相邻（距离不超过1ULP）(特殊情况：在2的指数幂和它左侧的浮点数比较时，容忍范围扩大为原先的2倍)。当然我们也可以将<code>EPSILON</code>取值为1.0时ULP特殊值的若干倍，这样就是可以在两个浮点数相邻若干个ULP时，都认为它们是接近的，相当于扩大了"相近"的容忍范围。</p></li>
<li><p>编辑距离比较（edit distance），也就是说在a, b两个浮点数之间还有多少个有效的浮点数。使用这种方法的函数比较难以计算，一般只用于已知两个距离非常接近的数之间，还有就是<strong>两个非规格化浮点数的比较情况</strong>。想象一个极端的情况: 32位浮点数的最小非规格化数0x00000001（<span class="math inline">\(2^{-149}\)</span>）和它相邻的下一个浮点数0x0000002（<span class="math inline">\(2^{-148}\)</span>），两者之间只相差了一个ULP，但是差值占比却是50%！在这样的情况下，理论上使用相对距离比较就是不行的；在实际操作上，由于<code>max * epsilon</code>的值小于最小非规格化浮点数，会直接舍入为0.0。因此，两个非规格化的浮点数的近似比较一般不使用相对距离。</p></li>
</ul>
<h2 id="对引言的回答">对引言的回答</h2>
<p>在有了前面所有的基础之后，我们再来看引言中提到的循环的控制条件<code>while (Math.abs(t - a / t) &gt; EPSILON * t)</code></p>
<p>首先，由于t最后收敛于<span class="math inline">\(\sqrt a\)</span>，因此<code>t</code>和<code>a / t</code>的double值必然会越来越接近。在这两个值中，<code>t</code>是较大的那一个（前文证明过数列的单调性），因此循环条件的反面就是<code>if (Math.abs(t - a / t) &lt;= EPSILON * Math.max(t, a / t))</code>，这就是标准的相对距离比较时用到的条件判断式。</p>
<p>其次，我们再来说<code>EPSILON</code>，这里<code>EPSILON</code>定义为1e-15。浮点数是不能准确表示1e-15的，这里实际上是它的近似值1.00000000000000007770539987666E-15(0x3CD203AF9EE75616)。想必已经发现了，它是一个大于1.0时ULP的一个浮点数。这就意味着，我们允许两个浮点数相距4.5个ULP。如果使用1e-16或者比1.0时ULP更小的浮点数，那么条件判断式就退化为必须两个浮点数相等了，此时就存在一种无限循环下去的风险。</p>
<p>最后，我们说这个循环条件在面对所有规格化的double值时表现都是没有问题的，它的缺陷在于如果尝试进行两个非规格化的浮点数的距离比较，就会出现<code>max * epsilon</code>下溢为0的情况。但是，这里的好处是哪怕是最小的非规格化浮点数<code>Double.MIN_VALUE</code>（<span class="math inline">\(2^{-1074}\)</span>），它的Sqrt值也是一个规格化的浮点数(<span class="math inline">\(2^{-537} &gt; 2^{-1022}\)</span>)，此外，在将t初始化为a的条件下，第一次的t赋值语句<code>t = (t + a / t) / 2.0</code>实际上就是<code>(a + 1.0) / 2.0</code>，这里a直接被舍入掉了，就如同（float条件下）1e10 + 3.14一样。因此，之后的t值一直是在规格化浮点数的范围内进行改变的。</p>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="https://www.ruanyifeng.com/blog/2010/06/ieee_floating-point_representation.html">浮点数的二进制表示</a></li>
<li><a href="https://stackoverflow.com/questions/6883306/floating-point-comparison-a-0-7">[stackoverflow] Floating point comparison a != 0.7</a></li>
<li><a href="https://en.wikipedia.org/wiki/IEEE_754-1985">[wikipedia] IEEE 754-1985</a></li>
<li>深入理解计算机系统（原书第三版）</li>
<li><a href="http://www.binaryconvert.com/index.html">Online Binary-Decimal Converter</a></li>
<li><a href="https://stackoverflow.com/questions/9314534/why-does-changing-0-1f-to-0-slow-down-performance-by-10x">[stackoverflow] Why does changing 0.1f to 0 slow down performance by 10x?</a></li>
<li><a href="https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/">Comparing Floating Point Numbers, 2012 Edition</a></li>
<li><a href="https://cs.stackexchange.com/questions/98152/condition-of-square-root-algorithm-newtons-method">Condition of square root algorithm (Newton's method)</a></li>
<li><a href="https://www.boost.org/doc/libs/1_73_0/libs/math/doc/html/math_toolkit/float_comparison.html">Floating-point Comparison</a></li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>二分搜索的模板和细节</title>
    <url>/posts/19345/</url>
    <content><![CDATA[<p>最近做Leetcode题目总是遇到二分搜索的问题，本来觉得之前自己已经把这方面搞的很明白了，但是写起来还是各种别扭不痛快。问题主要集中于循环条件控制：是<code>while(left &lt;= right)</code>还是<code>while(left &lt; right)</code>，左右边界的缩小：是<code>left = mid + 1</code>还是<code>left = mid</code>，中值的计算问题：是<code>mid = left + (right - left) / 2</code>还是<code>mid = left + (right - left + 1) / 2</code>。今天的这篇文章就想把这些问题都说清楚。</p>
<p>首先我还是参考了网上<a href="https://github.com/labuladong/fucking-algorithm/blob/master/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E8%AF%A6%E8%A7%A3.md">labuladong写的文章</a>的，感觉很受启发，其实很多算法都是有固定的模板的，不需要我们自己做什么创新。当然，这要能充分理解模板代码才行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 二分搜索的标准模板</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> len, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> right = len - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (arr[mid] &lt; target) left = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &gt; target) right = mid - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] == target) <span class="keyword">return</span> mid; <span class="comment">// find one, directly return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// can not find target</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个问题，循环控制。这里如果说我们采用左右包含的区间设定，即<code>[left, right]</code>的话，那么循环的控制条件就应该是<code>while(left &lt;= right)</code>，因为只有这样，才能说保证我们遍历了（有序数组中）所有的可能性。此时循环结束的条件是<code>left = right + 1</code>，最后一轮循环一定是<code>left == right</code>。如果说我们使用<code>while(left &lt; right)</code>，那么就会错过数组中的一个元素<code>[left, left]</code>。</p>
<p>因为我个人是喜欢进行左右包含的区间分析的，所以左闭右开的设定我就不想涉及了。以后都应该按此模板来进行。</p>
<p>第二个问题，中值计算问题，这里一律使用<code>mid = left + (right - left) / 2</code>的操作，这个操作的意思等价于<code>mid = (left + right) / 2</code>，但是由于能够避免<code>left</code>,<code>right</code>的值过大造成加法溢出的问题，因此是一种更好的写法。之前自己总是纠结于这种中值的计算是在两个数相邻时取偏左侧的值（比如[3, 4]时取3），因而可以和边界缩小配合（比如说right = mid）防止无限循环。现在一律不要再进行这样复杂的思考了，中值计算问题一律使用这个定式。</p>
<p>第三个问题，左右边界的缩小，（由于我们规定了左右包含的区间设定）这里一律使用<code>left = mid + 1</code>或者<code>right = mid - 1</code>，再也不要出现<code>left/right = mid</code>的操作，可以保证循环正常结束。</p>
<p>对于一般的二分搜索要求，上面的模板代码已经完全可以解决。稍微复杂点的有下面两种变形情况：</p>
<p><strong>左侧边界的二分搜索</strong></p>
<p>如果存在target，那么就返回最左侧的那一个的索引值</p>
<p>如果不存在target，那么就返回（假如）插入target后target值所在的索引值</p>
<p>我们可以把左侧边界的二分搜索理解为：在原始的数组中，找到满足<code>arr[index] &gt;= target</code>的最小index值</p>
<p>一个明显的例子就是，对于数组<code>[1, 3, 3, 3, 4]</code>，target = 3时正常的二分搜索返回index = 2（对应中间的那个3）；左侧边界的二分搜索要求返回index = 1（对应左侧的那个3）</p>
<p>对于正常的二分搜索，返回值的范围是<code>[0, len - 1]</code>；对于左侧边界的二分搜索，返回值的可能范围是<code>[0, len]</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 左侧边界的二分搜索</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> len, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> right = len - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (arr[mid] &lt; target) left = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &gt; target) right = mid - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] == target) right = mid - <span class="number">1</span>; <span class="comment">// find left bound</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>右侧边界的二分搜索</strong></p>
<p>如果存在target，那么就返回最右侧的那一个的索引值</p>
<p>如果不存在target，那么就返回（假如）插入target后在target值之前的那个元素的索引值</p>
<p>我们可以把右侧边界的二分搜索理解为：在原始的数组中，找到满足<code>arr[index] &lt;= target</code>的最大index值</p>
<p>对于正常的二分搜索，返回值的范围是<code>[0, len - 1]</code>；对于右侧边界的二分搜索，返回值的可能范围是<code>[-1, len - 1]</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 右侧边界的二分搜索</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> len, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> right = len - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (arr[mid] &lt; target) left = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &gt; target) right = mid - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] == target) left = mid + <span class="number">1</span>; <span class="comment">// find right bound</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由此，我们可以获得任意条件下的二分搜索代码模板，比如说以获得<code>arr[index] &lt; target</code>的最大index值，那么其代码（无脑）可以写作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// the largest index that arr[index] &lt; target </span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> len, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> right = len - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (arr[mid] &lt; target) left = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &gt; target) right = mid - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] == target) ; <span class="comment">// 待定1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ; <span class="comment">// 待定2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>待定1：由于我们希望获得小于<code>target</code>的最大index值，所以当遇到<code>arr[mid] == target</code>时，理应继续往前找看看有没有更小的值，所以<code>right = mid - 1</code></p>
<p>待定2：考虑到最后一轮循环的情况一定是<code>left == right</code>，此时分支代码告诉我们：[0, left - 1]的这些数一定满足<code>arr[mid] &lt; target</code>；[right + 1, len - 1]的这些数一定满足<code>arr[mid] &gt;= target</code>，也就是说，现在需要分析的范围被缩小到了只包含一个元素的[left, right]区间</p>
<p>此时如果说<code>arr[mid] &lt; target</code>，那么就意味着[0, left]的数都满足<code>arr[mid] &lt; target</code>，[right + 1, len - 1]的数都满足<code>arr[mid] &gt;= target</code>，所以说此时的这个mid就是我们要找的最大index值，因为最后一次更新是<code>left = mid + 1</code>，也就是说，<code>right</code>变量保存了这个mid，应该返回<code>right</code></p>
<p>如果说<code>arr[mid] &gt;= target</code>，那么就意味着[0, left - 1]的数都满足<code>arr[mid] &lt; target</code>，[right, len - 1]的数都满足<code>arr[mid] &gt;= target</code>，所以说此时的这个mid - 1就是我们要找的最大index值，因为最后一次更新是<code>right = mid - 1</code>，也就是说，<code>right</code>变量保存了这个mid - 1，应该返回<code>right</code></p>
]]></content>
  </entry>
  <entry>
    <title>C语言中的运算符优先级辨析</title>
    <url>/posts/32095/</url>
    <content><![CDATA[<p>最近使用C语言写MIT 6.S081课程的作业，发现自己对于C语言中的类似<code>*</code>，<code>&amp;</code>，<code>[]</code>，<code>-&gt;</code>符号的运算优先级和结合顺序问题理解并不清楚，这篇文章就是要彻底的理解这些个符号的运算优先级和代表的意义，保证以后凡是看到这样的符号，就都不会心里发慌。</p>
<p>首先，我们要明确，C语言的符号优先级（Precedence）规定了运算符（Operator）的运算顺序，优先级高的符号会先进行运算，然后才轮到优先级低的符号运算。<strong>只有对于相同符号优先级的两个运算符，此时讨论结合顺序才是有意义的</strong>。结合顺序（Associativity）规定了（在相同优先级符号的情况下）先计算哪个符号的问题。</p>
<p><strong>在同等优先级（Precedence）的情况下，所有的运算符结合顺序（Associativity）一定相同（都是从左到右或者都是从右到左）</strong></p>
<p>举例说明优先级不同造成的区别：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 由于优先级 * 高于 + 高于 =</span></span><br><span class="line"><span class="comment">// 因此先进行乘法（*）运算，后进行加法（+）运算，最后进行赋值（=）运算</span></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">7</span> + <span class="number">3</span> * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于优先级 ==, != 高于 &amp;, ^</span></span><br><span class="line"><span class="comment">// 因此对于位测试，需要通过()来实现parenthesized expression，才能得到正确结果</span></span><br><span class="line"><span class="keyword">if</span> ((x &amp; MASK) == <span class="number">0</span>) ...</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 由于优先级 -&gt; 高于 (prefix)++</span></span><br><span class="line"><span class="comment">// 因此表达式等价于++(p-&gt;len)，增加的是len的值</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> len;</span><br><span class="line">  <span class="keyword">char</span> *str;</span><br><span class="line">&#125; *p;</span><br><span class="line">++p-&gt;len;</span><br></pre></td></tr></table></figure>
<p>优先级相同情况下，结合顺序造成的区别：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 由于+,-的结合顺序是从左到右</span></span><br><span class="line"><span class="comment">// 因此先进行左边的+运算，再进行右边的-运算</span></span><br><span class="line"><span class="comment">// 整个表达式等价于(2 + 3) - 5</span></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">2</span> + <span class="number">3</span> - <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前缀++,--和*,&amp;同级，属于从右向左结合</span></span><br><span class="line"><span class="comment">// 后缀++,--和function call()同级，属于从左向右结合</span></span><br><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">10</span>, <span class="number">20</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *p = arr;</span><br><span class="line"><span class="keyword">switch</span>(...) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="comment">// 表达式等价于++(*p), arr[] = &#123;11, 20&#125;, p = &amp;arr[0]</span></span><br><span class="line">    ++*p;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    <span class="comment">// 表达式等价于*(++p), arr[] = &#123;10, 21&#125;, p = &amp;arr[1]</span></span><br><span class="line">    *++p = <span class="number">21</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    <span class="comment">// 表达式等价于*(p++), arr[] = &#123;11, 20&#125;, p = &amp;arr[1]</span></span><br><span class="line">  	*p++ = <span class="number">11</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意，只有单个运算符的情况下，</span></span><br><span class="line"><span class="comment">// +保证从左到右的结合顺序，但是不能保证 f1() 先执行， f2() 后执行</span></span><br><span class="line"><span class="keyword">int</span> y = f1() + f2();</span><br><span class="line"><span class="comment">// 相反，多个同级运算符的情况下，就可以局部保证执行顺序，但f3()可以最先执行，也可以最后执行，还可以在f1(), f2()之间执行</span></span><br><span class="line"><span class="comment">// 表达式等价于(f1() + f2()) + f3()</span></span><br><span class="line"><span class="keyword">int</span> z = f1() + f2() + f3();</span><br></pre></td></tr></table></figure>
<p>关于前缀和（Prefix ++）以及后缀和（Suffix ++）的问题，可以参考这篇文章<a href="https://mp.weixin.qq.com/s/FeScrJt5UidqcFBoJqYi9w">显微镜下的 i++ 与 ++i</a>的内容，简而言之就是：</p>
<p>前缀和 ++i：先将局部变量表中的i值+1，再将i放入操作数栈中</p>
<p>后缀和 i++：先将局部变量表中的i放入操作数栈中，再将局部变量表中的i值+1</p>
<p>这其中，操作数栈中的数值就是后续运算（比如说赋值运算<code>int a = i++;</code>）中要操作的数值，因此我们也可以说：</p>
<p><strong>前缀和 ++i：变量i的值+1，整个表达式(++i)的值（操作数栈中存入的值）是变量i的新值</strong></p>
<p><strong>后缀和 i++：变量i的值+1，整个表达式(i++)的值（操作数栈中存入的值）是变量i的原始值</strong></p>
<p>当然，对于指针类型的变量（比如说<code>int *p</code>），前缀和(<code>++p</code>)和后缀和(<code>p++</code>)每一次操作就不是+1了，而是+sizeof(*p)</p>
<p>例如，<code>(++p)-&gt;len</code>先执行<code>p</code>的<code>+sizeof(*p)</code>的操作，然后再返回这个新<code>p</code>的len值；<code>(p++)-&gt;len</code>则返回的是原始<code>p</code>的len值，然后再执行<code>p</code>的<code>+sizeof(*p)</code>的操作</p>
<p>全部的运算符优先级可以在网上搜索<a href="https://en.cppreference.com/w/c/language/operator_precedence">C language operator precedence</a>得到，这里仅列出本文关注的若干运算符：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Operator</th>
<th style="text-align: center;">Description</th>
<th style="text-align: center;">Associativity</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">[]</td>
<td style="text-align: center;">Array subscript</td>
<td style="text-align: center;">left to right</td>
</tr>
<tr class="even">
<td style="text-align: center;">-&gt;</td>
<td style="text-align: center;">Member selection via pointer</td>
<td style="text-align: center;">-</td>
</tr>
<tr class="odd">
<td style="text-align: center;">++</td>
<td style="text-align: center;">Suffix increment</td>
<td style="text-align: center;">-</td>
</tr>
<tr class="even">
<td style="text-align: center;">()</td>
<td style="text-align: center;">Function call</td>
<td style="text-align: center;">-</td>
</tr>
<tr class="odd">
<td style="text-align: center;">*</td>
<td style="text-align: center;">Dereference</td>
<td style="text-align: center;">right to left</td>
</tr>
<tr class="even">
<td style="text-align: center;">&amp;</td>
<td style="text-align: center;">Address (of operand)</td>
<td style="text-align: center;">-</td>
</tr>
<tr class="odd">
<td style="text-align: center;">++</td>
<td style="text-align: center;">Prefix increment</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<p>注意这里的<code>()</code>表示的含义是函数调用（Function call），它也被认为是一种后缀表达式（Postfix Expression），这不同于我们在数学上常用的添加括号（Parentheses）来改变运算顺序的情况。添加括号来改变运算顺序的情况（Parenthesized Expression）是构造了一种初等表达式（Primary Expression）。将括号内的表达式看作是一个整体，其类型和值与无括号的表达式相同。从某种意义上讲，添加括号（Parenthesized Expression）的这种情况是比函数调用<code>()</code>更高的优先级。</p>
<p>其中，<code>[]</code>，<code>-&gt;</code>同级，它们和<code>()</code>一样，属于最高优先级的那一类运算符；<code>*</code> ，<code>&amp;</code>同级，它们属于第二档优先级的运算符。</p>
<p>对于<code>-&gt;</code>符号来说，它是一种对于结构体（struct）指针的简便写法，对于结构体指针<code>p</code>，<code>p-&gt;str</code>等价于<code>(*p).str</code></p>
<p>由于我们有了运算符的优先级和结合顺序，因此也就可以由此读懂复杂的类型声明代码。其中，<strong>所有的类型声明语法都应该从里到外（按照优先级顺序）来读</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 变量f是一个function，这个函数的返回值是一个pointer，这个pointer指向int，参数情况未知</span></span><br><span class="line"><span class="comment">// function call operator () 只表示函数，并未规定函数参数情况</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 变量pf是一个pointer，这个指针指向一个函数，这个函数的返回值是int，参数情况未知</span></span><br><span class="line"><span class="keyword">int</span> (*pf)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 变量daytab是一个pointer，这个指针指向一个数组，这个数组长度为13，数组中存储的元素是int类型</span></span><br><span class="line"><span class="keyword">int</span> (*daytab)[<span class="number">13</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 变量daytab是一个array，这个数组长度为13，数组中存储的元素是pointer，每个pointer指向一个int</span></span><br><span class="line"><span class="keyword">int</span> *daytab[<span class="number">13</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 变量comp是一个function，这个函数返回值是一个pointer，这个pointer指向void（全能指针），参数情况未知</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">comp</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 变量comp是一个pointer，这个指针指向一个函数，函数的返回值是void，参数情况未知</span></span><br><span class="line"><span class="keyword">void</span> (*comp)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 变量x是一个function，这个函数返回一个指针，指针指向一个数组，这个数组中的每个元素都是一个指针，而且都是指向返回值为char的某个函数的指针</span></span><br><span class="line"><span class="keyword">char</span> (*(*x())[])();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 变量x是一个array，这个数组长度为3，数组中的每个元素都是一个指针，而且都是指向某个函数的指针。其中这个函数也返回一个指针，这个指针是指向一个长度为5的数组，这个数组中的每个元素类型为char</span></span><br><span class="line"><span class="keyword">char</span> (*(*x[<span class="number">3</span>])())[<span class="number">5</span>];</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
</search>
